// auto-generated by Codex Directive 01 â€” Validator Core
import Ajv from "ajv";
import addFormats from "ajv-formats";

const DEFAULT_AJV_OPTIONS = {
  allErrors: true,
  strict: true,
  allowUnionTypes: true,
  $data: true,
};

const REF_PREFIX = "#/$defs/";

function registerFormats(ajvInstance, formats = []) {
  formats.forEach((format) => {
    if (typeof format?.name !== "string" || typeof format?.definition === "undefined") {
      return;
    }

    if (ajvInstance.getFormat(format.name)) {
      ajvInstance.removeFormat(format.name);
    }

    ajvInstance.addFormat(format.name, format.definition);
  });
}

function ensureSchemaKey(schema, fallbackKey) {
  if (schema && typeof schema === "object") {
    if (typeof schema.$id === "string" && schema.$id.length > 0) {
      return schema.$id;
    }
    if (typeof schema.$async === "string" && schema.$async.length > 0) {
      return schema.$async;
    }
  }
  return fallbackKey;
}

function expandLocalRefs(schema) {
  if (!schema || typeof schema !== "object") {
    return schema;
  }

  const definitions = schema.$defs || {};

  const expandNode = (node, stack = []) => {
    if (!node || typeof node !== "object") {
      return node;
    }

    if (Array.isArray(node)) {
      return node.map((item) => expandNode(item, stack));
    }

    if (typeof node.$ref === "string" && node.$ref.startsWith(REF_PREFIX)) {
      const key = node.$ref.substring(REF_PREFIX.length);
      const target = definitions[key];

      if (!target) {
        return node;
      }

      if (stack.includes(key)) {
        return { ...target };
      }

      return expandNode(target, [...stack, key]);
    }

    return Object.keys(node).reduce((acc, key) => {
      acc[key] = expandNode(node[key], stack);
      return acc;
    }, {});
  };

  return {
    ...schema,
    $defs: definitions,
    properties: expandNode(schema.properties),
  };
}

export class ValidatorCore {
  constructor(options = {}) {
    const {
      ajvOptions = {},
      schemas = [],
      formats = [],
      preprocess = true,
    } = options;

    this.ajv = new Ajv({ ...DEFAULT_AJV_OPTIONS, ...ajvOptions });
    addFormats(this.ajv);
    registerFormats(this.ajv, formats);

    if (Array.isArray(schemas)) {
      schemas.forEach((schema, index) => {
        this.registerSchema(schema, { preprocess, fallbackKey: `schema_${index}` });
      });
    }
  }

  registerSchema(schema, options = {}) {
    const { preprocess = true, fallbackKey } = options;
    if (!schema || typeof schema !== "object") {
      throw new TypeError("Schema must be an object");
    }

    const schemaKey = ensureSchemaKey(schema, fallbackKey);
    const preparedSchema = preprocess ? expandLocalRefs(schema) : schema;

    if (schemaKey) {
      this.ajv.removeSchema(schemaKey);
    }

    this.ajv.addSchema(preparedSchema, schemaKey);
    return schemaKey;
  }

  getSchema(schemaKey) {
    return this.ajv.getSchema(schemaKey);
  }

  validate(schemaKey, data) {
    const validator = this.getSchema(schemaKey);
    if (!validator) {
      throw new Error(`Schema not found for key: ${schemaKey}`);
    }

    const valid = validator(data);
    return {
      valid,
      errors: valid ? [] : validator.errors ?? [],
    };
  }

  compile(schema, options = {}) {
    const key = this.registerSchema(schema, options);
    return this.getSchema(key);
  }
}

export const createValidatorCore = (options) => new ValidatorCore(options);
