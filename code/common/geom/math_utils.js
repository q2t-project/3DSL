// auto-generated by Codex Directive 09 â€” Math Utilities
const EPSILON = 1e-6;

export const clamp = (value, min = 0, max = 1) => Math.min(Math.max(value, min), max);
export const lerp = (a, b, t) => a + (b - a) * t;
export const degToRad = (degrees) => (degrees * Math.PI) / 180;
export const radToDeg = (radians) => (radians * 180) / Math.PI;

export function approxEqual(a, b, tolerance = EPSILON) {
  return Math.abs(a - b) <= tolerance;
}

export function addVectors(a, b) {
  return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];
}

export function subtractVectors(a, b) {
  return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
}

export function scaleVector(vector, scalar) {
  return [vector[0] * scalar, vector[1] * scalar, vector[2] * scalar];
}

export function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

export function cross(a, b) {
  return [
    a[1] * b[2] - a[2] * b[1],
    a[2] * b[0] - a[0] * b[2],
    a[0] * b[1] - a[1] * b[0],
  ];
}

export function length(vector) {
  return Math.sqrt(dot(vector, vector));
}

export function normalize(vector, tolerance = EPSILON) {
  const len = length(vector);
  if (len <= tolerance) {
    return [0, 0, 0];
  }
  return scaleVector(vector, 1 / len);
}

export function distance(a, b) {
  return length(subtractVectors(a, b));
}

export function midpoint(a, b) {
  return scaleVector(addVectors(a, b), 0.5);
}

export function mixVectors(a, b, t) {
  return [
    lerp(a[0], b[0], t),
    lerp(a[1], b[1], t),
    lerp(a[2], b[2], t),
  ];
}

export function quaternionFromEuler([x, y, z]) {
  const c1 = Math.cos(x / 2);
  const c2 = Math.cos(y / 2);
  const c3 = Math.cos(z / 2);
  const s1 = Math.sin(x / 2);
  const s2 = Math.sin(y / 2);
  const s3 = Math.sin(z / 2);

  return [
    s1 * c2 * c3 + c1 * s2 * s3,
    c1 * s2 * c3 - s1 * c2 * s3,
    c1 * c2 * s3 + s1 * s2 * c3,
    c1 * c2 * c3 - s1 * s2 * s3,
  ];
}

export function matrixMultiply(a, b) {
  const result = new Array(16).fill(0);
  for (let row = 0; row < 4; row += 1) {
    for (let col = 0; col < 4; col += 1) {
      let sum = 0;
      for (let k = 0; k < 4; k += 1) {
        sum += a[row * 4 + k] * b[k * 4 + col];
      }
      result[row * 4 + col] = sum;
    }
  }
  return result;
}

export function identityMatrix() {
  return [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1,
  ];
}

export function translateMatrix([x, y, z]) {
  const matrix = identityMatrix();
  matrix[12] = x;
  matrix[13] = y;
  matrix[14] = z;
  return matrix;
}

export function scaleMatrix([x, y, z]) {
  const matrix = identityMatrix();
  matrix[0] = x;
  matrix[5] = y;
  matrix[10] = z;
  return matrix;
}

export function transformVector(matrix, vector) {
  const [x, y, z] = vector;
  const w = matrix[3] * x + matrix[7] * y + matrix[11] * z + matrix[15];
  const nx = matrix[0] * x + matrix[4] * y + matrix[8] * z + matrix[12];
  const ny = matrix[1] * x + matrix[5] * y + matrix[9] * z + matrix[13];
  const nz = matrix[2] * x + matrix[6] * y + matrix[10] * z + matrix[14];
  if (w && w !== 1) {
    return [nx / w, ny / w, nz / w];
  }
  return [nx, ny, nz];
}

export default {
  EPSILON,
  clamp,
  lerp,
  degToRad,
  radToDeg,
  approxEqual,
  addVectors,
  subtractVectors,
  scaleVector,
  dot,
  cross,
  length,
  normalize,
  distance,
  midpoint,
  mixVectors,
  quaternionFromEuler,
  matrixMultiply,
  identityMatrix,
  translateMatrix,
  scaleMatrix,
  transformVector,
};
