// auto-generated by Codex Directive 12 â€” Diff Checker
const CHANGE_ADDED = "added";
const CHANGE_REMOVED = "removed";
const CHANGE_MODIFIED = "modified";
const CHANGE_UNCHANGED = "unchanged";

function isObject(value) {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}

function compareValues(key, left, right, path) {
  if (left === right) {
    return { type: CHANGE_UNCHANGED, path, key, before: left, after: right };
  }

  if (typeof left === "undefined") {
    return { type: CHANGE_ADDED, path, key, before: undefined, after: right };
  }

  if (typeof right === "undefined") {
    return { type: CHANGE_REMOVED, path, key, before: left, after: undefined };
  }

  if (isObject(left) && isObject(right)) {
    return { type: CHANGE_MODIFIED, path, key, before: left, after: right, children: diffObjects(left, right, path.concat(key)) };
  }

  if (Array.isArray(left) && Array.isArray(right)) {
    return { type: CHANGE_MODIFIED, path, key, before: left, after: right, children: diffArrays(left, right, path.concat(key)) };
  }

  return { type: CHANGE_MODIFIED, path, key, before: left, after: right };
}

export function diffObjects(left = {}, right = {}, path = []) {
  const keys = new Set([...Object.keys(left || {}), ...Object.keys(right || {})]);
  const changes = [];
  keys.forEach((key) => {
    const change = compareValues(key, left?.[key], right?.[key], path);
    if (change.type !== CHANGE_UNCHANGED || change.children?.length) {
      changes.push(change);
    }
  });
  return changes;
}

export function diffArrays(left = [], right = [], path = []) {
  const maxLength = Math.max(left.length, right.length);
  const changes = [];
  for (let index = 0; index < maxLength; index += 1) {
    const change = compareValues(index, left[index], right[index], path);
    if (change.type !== CHANGE_UNCHANGED || change.children?.length) {
      changes.push(change);
    }
  }
  return changes;
}

export function hasChanges(diff) {
  return diff.some((change) => change.type !== CHANGE_UNCHANGED || (Array.isArray(change.children) && change.children.length > 0));
}

export function summarizeDiff(diff) {
  return diff.reduce(
    (summary, change) => {
      summary[change.type] = (summary[change.type] || 0) + 1;
      if (change.children) {
        const childSummary = summarizeDiff(change.children);
        Object.entries(childSummary).forEach(([type, count]) => {
          summary[type] = (summary[type] || 0) + count;
        });
      }
      return summary;
    },
    { [CHANGE_ADDED]: 0, [CHANGE_REMOVED]: 0, [CHANGE_MODIFIED]: 0, [CHANGE_UNCHANGED]: 0 },
  );
}

export const DiffChangeType = {
  ADDED: CHANGE_ADDED,
  REMOVED: CHANGE_REMOVED,
  MODIFIED: CHANGE_MODIFIED,
  UNCHANGED: CHANGE_UNCHANGED,
};
