// auto-generated by Codex Directive 11 â€” Cache Manager
import { Logger } from "./logger.js";

class CacheEntry {
  constructor(value, ttl) {
    this.value = value;
    this.expiresAt = ttl > 0 ? Date.now() + ttl : null;
  }

  isExpired(reference = Date.now()) {
    return this.expiresAt !== null && reference >= this.expiresAt;
  }
}

export class CacheManager {
  constructor(options = {}) {
    this.logger = options.logger ?? new Logger("cache");
    this.clock = options.clock ?? (() => Date.now());
    this.store = new Map();
  }

  set(key, value, ttl = 0) {
    this.store.set(key, new CacheEntry(value, ttl));
    this.logger.info("CACHE_SET", { key, ttl });
    return value;
  }

  get(key) {
    const entry = this.store.get(key);
    if (!entry) {
      this.logger.warn("CACHE_MISS", { key });
      return undefined;
    }

    if (entry.isExpired(this.clock())) {
      this.logger.warn("CACHE_EXPIRED", { key });
      this.store.delete(key);
      return undefined;
    }

    this.logger.info("CACHE_HIT", { key });
    return entry.value;
  }

  has(key) {
    return typeof this.get(key) !== "undefined";
  }

  delete(key) {
    const deleted = this.store.delete(key);
    if (deleted) {
      this.logger.info("CACHE_DELETE", { key });
    }
    return deleted;
  }

  clear() {
    this.store.clear();
    this.logger.info("CACHE_CLEAR");
  }

  purgeExpired() {
    const now = this.clock();
    [...this.store.entries()].forEach(([key, entry]) => {
      if (entry.isExpired(now)) {
        this.store.delete(key);
        this.logger.warn("CACHE_PURGE_EXPIRED", { key });
      }
    });
  }
}

export const createCacheManager = (options) => new CacheManager(options);
