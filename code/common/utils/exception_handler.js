// auto-generated by Codex Directive 03 â€” Exception Handler
import { Logger } from "./logger.js";

const DEFAULT_ERROR_CODE = "E_UNKNOWN";

function buildErrorPayload(error, context = {}) {
  if (!error) {
    return {
      code: DEFAULT_ERROR_CODE,
      message: "Unknown error",
      context,
      recoverable: false,
    };
  }

  if (typeof error === "string") {
    return {
      code: context.code || DEFAULT_ERROR_CODE,
      message: error,
      context,
      recoverable: Boolean(context.recoverable),
    };
  }

  if (error instanceof Error) {
    return {
      code: error.code || context.code || DEFAULT_ERROR_CODE,
      message: error.message,
      stack: error.stack,
      context,
      recoverable: Boolean(error.recoverable ?? context.recoverable),
    };
  }

  return {
    code: error.code || context.code || DEFAULT_ERROR_CODE,
    message: error.message || "Unhandled exception",
    details: error.details,
    context,
    recoverable: Boolean(error.recoverable ?? context.recoverable),
  };
}

export class ExceptionHandler {
  constructor(options = {}) {
    this.logger = options.logger ?? new Logger("exception");
    this.transformers = Array.isArray(options.transformers) ? options.transformers : [];
  }

  registerTransformer(transformer) {
    if (typeof transformer === "function") {
      this.transformers.push(transformer);
    }
  }

  normalize(error, context = {}) {
    const payload = buildErrorPayload(error, context);
    return this.transformers.reduce((result, transformer) => {
      try {
        return transformer(result, context) ?? result;
      } catch (transformerError) {
        this.logger.warn("TRANSFORMER_FAIL", {
          transformer: transformer.name || "anonymous",
          message: transformerError.message,
        });
        return result;
      }
    }, payload);
  }

  capture(error, context = {}) {
    const normalized = this.normalize(error, context);
    this.logger.error(context.event || "EXCEPTION", normalized);
    return normalized;
  }

  wrap(fn, context = {}) {
    return async (...args) => {
      try {
        const result = await fn(...args);
        return { ok: true, result };
      } catch (error) {
        return { ok: false, error: this.capture(error, context) };
      }
    };
  }
}

export const createExceptionHandler = (options) => new ExceptionHandler(options);
