runtime_spec:

version: "2.1-draft"

description: "3DSL Viewer Runtime Manifest – holy API spec for 3DSL Viewer"

# =========================================================

# 0. レイヤ定義 ＋ 依存ルール

# =========================================================

layers:
- name: entry
description: "Host（Astro/HTML）から叩かれるエントリポイント層"
- name: hub
description: "UI と core / renderer の集線層（ロジック禁止）"
- name: core
description: "状態とビジネスロジックの中枢。3DSS は read-only"
- name: renderer
description: "three.js による描画専用。state-less 指向"
- name: ui
description: "UI イベント → hub.core.* への橋渡し層（dev harness / 本番 host 側）"

dependency_rules:
# 正方向
- "ui        → hub       → core      → renderer"

```
# 禁止方向（絶対）
- "core      → hub:       FORBIDDEN"
- "renderer  → core:      FORBIDDEN"
- "renderer  → hub:       FORBIDDEN"
- "hub       → ui:        FORBIDDEN"
- "ui        → renderer:  FORBIDDEN（pick も hub 経由）"
```

# =========================================================

# 1. state 所有権

# =========================================================

ownership:
uiState:        "core"
visibleSet:     "core"
microState:     "core"
cameraState:    "core"
document_3dss:  "core (immutable)"
three_objects:  "renderer"

# =========================================================

# 2. モジュール一覧

# =========================================================

modules:

```
# =========================
# 2.1 entry
# =========================
- name: runtime/bootstrapViewer.js
  layer: entry
  responsibility:
    - "canvas と 3DSS JSON を受け取り、runtime 一式を初期化する"
    - "URL から JSON をロードし、AJV で strict validate する"
    - "core / renderer / viewerHub を生成して返す"
    - "PointerInput / KeyboardInput を構築し、canvas / window に 1 回だけ attach する"
    - "（dev オプションが指定された場合）起動診断ログ（BOOT/MODEL/CAMERA/LAYERS/FRAME）を発行する"
  exports:
    - name: bootstrapViewer
      signature: "(canvasOrId, threeDSS, options?) → hub"
    - name: bootstrapViewerFromUrl
      signature: "(canvasOrId, url, options?) → Promise<hub>"
    - name: ViewerBootstrapOptions
      fields:
        - name: devBootLog
          type: "boolean"
          description: |
            起動時に BOOT/MODEL/CAMERA/LAYERS/FRAME の 5 レコードを発行するかどうか。
            true のときのみ logger に渡す。
        - name: devLabel
          type: "string"
          description: "BOOT ログに載せるラベル（例: 'viewer_dev' / 'viewer_embed'）"
        - name: modelUrl
          type: "string"
          description: "MODEL ログ payload に載せる識別子（URL または任意ラベル）"
        - name: logger
          type: "(line:string) => void"
          description: "devBootLog 出力先（未指定時は console.log 相当にフォールバックしてもよい）"
  calls:
    - runtime/core/uiState.createUiState
    - runtime/core/structIndex.buildUUIDIndex
    - runtime/core/structIndex.detectFrameRange
    - runtime/core/CameraEngine (constructor)
    - runtime/core/frameController.createFrameController
    - runtime/core/selectionController.createSelectionController
    - runtime/core/microController.createMicroController
    - runtime/core/visibilityController.createVisibilityController
    - runtime/core/modeController.createModeController
    - runtime/core/deepFreeze.deepFreeze
    - runtime/core/validator.initValidator
    - runtime/core/validator.validate3DSS
    - runtime/renderer/context.createRendererContext
    - runtime/viewerHub.createViewerHub
    - runtime/core/pointerInput.PointerInput
    - runtime/core/keyboardInput.KeyboardInput
  called_by:
    - "Host（Astro / HTML 側の起動コード / viewerDevHarness）"
  constraints:
    - "描画ループ（requestAnimationFrame）は持たない。hub.start に任せる"
    - "ui/* モジュールを import してはならない"
    - "3DSS が AJV で NG の場合は hub を生成せず Error を投げる"
    - "3DSS document は deepFreeze 済み immutable とみなす"
    - "PointerInput / KeyboardInput は bootstrap 内で 1 度だけ構築し、外部から直接 new させない"



# =========================
# 2.2 hub
# =========================
- name: runtime/viewerHub.js
  layer: hub
  responsibility:
    - "core と renderer を束ねて、UI に対して hub.core.* API を提供する"
    - "render loop（hub.start / hub.stop）を 1 箇所で管理する"
    - "UI からの呼び出しはすべて hub.core.* / hub.pickObjectAt に統一する"
  exports:
    - name: createViewerHub
      signature: "({ core, renderer }) → hub"
    - name: hub
      children:
        - core
        - start
        - stop
        - pickObjectAt
  hub_shape:
    core:
      props:
        - name: data
          description: "struct（3DSS document）。deep-freeze 済み、read-only。"
        - name: uiState
          description: "uiState オブジェクトそのもの。更新は core.* / controller 経由のみ許可。"
        - name: frame
          description: "frameController への公開ラッパ (set/get/step/range)。"
        - name: camera
          description: "CameraEngine への公開ラッパ (rotate/pan/zoom/reset/snapToAxis/…）。"
        - name: mode
          description: "modeController への公開ラッパ。"
        - name: selection
          description: "selectionController への公開ラッパ。"
        - name: filters
          description: "visibilityController の filters ラッパ。"
        - name: visibilityController
          description: "visibleSet 再計算の唯一の正規ルート。"
        - name: microController
          description: "microState 計算用 controller。"
        - name: frameController
          description: "frame 用 controller 本体（互換用）。"
        - name: cameraEngine
          description: "CameraEngine 本体（互換用）。"
  calls:
    - "core/frameController.*"
    - "core/selectionController.*"
    - "core/modeController.*"
    - "core/microController.*"
    - "core/visibilityController.*"
    - "core/CameraEngine.*"
    - "renderer/context.applyFrame"
    - "renderer/context.applyMicroFX"
    - "renderer/context.updateCamera"
    - "renderer/context.applySelection"
    - "renderer/context.pickObjectAt"
    - "renderer/context.render"
  called_by:
    - "runtime/core/pointerInput.js"
    - "runtime/core/keyboardInput.js"
    - "ui/gizmo.js"
    - "ui/picker.js"
    - "ui/timeline.js（将来の独立タイムライン UI を想定）"
    - "viewerDevHarness.js（dev viewer 専用 UI）"
  constraints:
    - "frame/mode/micro/selection の判定ロジックを hub に書いてはならない。必ず core.* に委譲する"
    - "three.js のオブジェクトや material を直接触ってはならない"
    - "3DSS document を直接変更してはならない"

  core_api:

    frame:
      - name: get
        signature: "() → number"
        calls:
          - core/frameController.get

      - name: set
        signature: "(frameIndex:number) → void"
        calls:
          - core/frameController.set

      - name: step
        signature: "(delta:number) → void"
        calls:
          - core/frameController.step

      - name: range
        signature: "() → {min:number,max:number}"
        calls:
          - core/frameController.range


    selection:
      - name: set
        signature: "(next:{uuid?:string,kind?:string}|null) → {kind:string|null, uuid:string|null}"
        calls:
          - core/selectionController.set

      - name: clear
        signature: "() → {kind:null, uuid:null}"
        calls:
          - core/selectionController.clear

      - name: get
        signature: "() → {kind:string|null, uuid:string|null}"
        calls:
          - core/selectionController.get


    camera:
      - name: rotate
        signature: "(dTheta:number, dPhi:number) → void"
        calls:
          - core/CameraEngine.rotate

      - name: pan
        signature: "(dx:number, dy:number) → void"
        calls:
          - core/CameraEngine.pan

      - name: zoom
        signature: "(delta:number) → void"
        calls:
          - core/CameraEngine.zoom

      - name: reset
        signature: "() → void"
        calls:
          - core/CameraEngine.reset

      - name: snapToAxis
        signature: "(axis:'x'|'y'|'z') → void"
        calls:
          - core/CameraEngine.snapToAxis

      - name: setFOV
        signature: "(value:number) → void"
        calls:
          - core/CameraEngine.setFOV

      - name: setState
        signature: "(partialState:object) → void"
        calls:
          - core/CameraEngine.setState

      - name: getState
        signature: "() → cameraState"
        calls:
          - core/CameraEngine.getState


    mode:
      - name: set
        signature: "(mode:'macro'|'meso'|'micro', uuid?:string) → 'macro'|'meso'|'micro'"
        calls:
          - core/modeController.set

      - name: get
        signature: "() → 'macro'|'meso'|'micro'"
        calls:
          - core/modeController.get

      - name: exit
        signature: "() → void"
        calls:
          - core/modeController.exit

      - name: focus
        signature: "(uuid:string) → void"
        calls:
          - core/modeController.focus


    micro:
      - name: enter
        signature: "(uuid:string) → void"
        calls:
          - core/modeController.set('micro', uuid)

      - name: exit
        signature: "() → void"
        calls:
          - core/modeController.exit

      - name: isActive
        signature: "() → boolean"
        impl_note: "uiState.mode === 'micro' を見るだけ（core 所有）"


    filters:
      - name: setTypeEnabled
        signature: "(kind:'points'|'lines'|'aux', enabled:boolean) → void"
        calls:
          - core/visibilityController.setTypeEnabled

      - name: get
        signature: "() → FiltersState"
        calls:
          - core/visibilityController.get


    runtime:
      # 再生制御については現状 dev harness 側実装とし、
      # runtime 側 API は将来拡張用に予約とする。
      - name: isFramePlaying
        signature: "() → boolean"
        impl_note: "uiState.runtime.isFramePlaying を返す（現状は dev viewer でのみ利用予定）"

      - name: isCameraAuto
        signature: "() → boolean"
        impl_note: "uiState.runtime.isCameraAuto を返す（将来の自動カメラ用）"



# =========================
# 2.3 core
# =========================
- name: runtime/core/CameraEngine.js
  layer: core
  responsibility:
    - "cameraState を内部に保持し、renderer に渡すための状態を作る"
  exports:
    - name: CameraEngine
      type: class
      methods:
        - rotate(dTheta:number, dPhi:number)
        - pan(dx:number, dy:number)
        - zoom(delta:number)
        - reset()
        - snapToAxis(axis:'x'|'y'|'z')
        - setState(partialState:object)
        - getState(): cameraState
        - setFOV(value:number)
  calls: []
  called_by:
    - "runtime/viewerHub.js（core.camera.* 経由）"
    - "core/modeController.js（フォーカス遷移時に参照する場合があれば）"
  state:
    - "cameraState を内部に保持する"
    - "three.js の Camera インスタンスは renderer が保持し、この state を反映するだけ"



- name: runtime/core/frameController.js
  layer: core
  responsibility:
    - "active frame を管理する"
    - "frameRange を決定し、uiState.frame に保持する"
  exports:
    - name: createFrameController
      returns: frameController
    - name: frameController
      methods:
        - set(frameIndex:number)
        - get(): number
        - step(delta:number)
        - range(): {min:number,max:number}
  calls:
    - core/visibilityController.recompute
  called_by:
    - "runtime/viewerHub.js（core.frame.* 経由）"
    - "KeyboardInput（PgUp/PgDn）"
  state:
    - "activeFrame と frameRange を uiState.frame に保持する"



- name: runtime/core/selectionController.js
  layer: core
  responsibility:
    - "現在の選択要素（kind, uuid）を管理する"
  exports:
    - name: createSelectionController
      returns: selectionController
    - name: selectionController
      methods:
        - set(next:{uuid?:string,kind?:string}|null)
        - clear()
        - get(): {kind:string|null, uuid:string|null}
  calls:
    - core/structIndex.buildUUIDIndex（が作った index を参照）
  called_by:
    - "runtime/viewerHub.js（core.selection.*）"
    - "core/modeController.js"
  state:
    - "uiState.selection = {kind, uuid} を更新する"



- name: runtime/core/modeController.js
  layer: core
  responsibility:
    - "mode（macro/meso/micro）と micro 侵入条件の優先ルールを管理する"
  exports:
    - name: createModeController
      returns: modeController
    - name: modeController
      methods:
        - set(mode:'macro'|'meso'|'micro', uuid?:string)
        - get(): 'macro'|'meso'|'micro'
        - canEnter(uuid:string): boolean
        - exit()
        - focus(uuid:string)
  calls:
    - core/selectionController.set
    - core/selectionController.get
    - core/microController.compute
    - core/frameController.get
    - core/visibilityController.isVisible
  called_by:
    - "runtime/viewerHub.js（core.mode.*, core.micro.*）"
    - "KeyboardInput（Q/W/Esc）"
  rules:
    - "frame 再生（将来実装する場合）開始時は必ず mode='macro' に戻す"
    - "micro/meso は visibleSet 内の要素にだけ適用される"
    - "canEnter は isFramePlaying / isCameraAuto / visibleSet をチェックする"
  state:
    - "uiState.mode を更新する"
    - "uiState.microState を microController.compute の結果で更新する"



- name: runtime/core/microController.js
  layer: core
  responsibility:
    - "selection + cameraState + structIndex から microState（= MicroFXPayload）を算出する"
  exports:
    - name: createMicroController
      returns: microController
    - name: microController
      methods:
        - compute(selection, cameraState, struct): MicroFXPayload | null
        - refresh(): void
  calls:
    - core/structIndex（uuid→kind / 近傍情報などを参照）
  called_by:
    - "core/modeController"
    - "core.recomputeVisibleSet()（bootstrapViewer が core にぶら下げる補助メソッド）"
  constraints:
    - "three.js を import してはならない"
    - "renderer に直接アクセスしてはならない"
  microState_shape:
    - "MicroFXPayload 型（3DSD-viewer.md 7.11 節）と同型のオブジェクト、または null を返す"
    - "renderer は unknown なフィールドは無視して良い"



- name: runtime/core/visibilityController.js
  layer: core
  responsibility:
    - "appearance.visible / frames / filters を合成し、visibleSet を計算する"
  exports:
    - name: createVisibilityController
      returns: visibilityController
    - name: visibilityController
      methods:
        - recompute(): visibleSet
        - isVisible(uuid:string): boolean
        - get(): FiltersState
        - setTypeEnabled(kind:'points'|'lines'|'aux', enabled:boolean)
  calls: []
  called_by:
    - "runtime/viewerHub.js（core.filters.*）"
    - "core/frameController"
    - "core/modeController"
  state:
    - "uiState.visibleSet を Set<uuid> として保持する"
    - "uiState.filters を {points,lines,aux} として保持する"



- name: runtime/core/uiState.js
  layer: core
  responsibility:
    - "viewer の UI 状態を一元管理する（document とは分離）"
  exports:
    - name: createUiState
      returns: uiState
  fields:
    - "frame.current: number"
    - "frame.range: {min:number,max:number}"
    - "selection: {kind:string|null, uuid:string|null}"
    - "cameraState: {theta,phi,distance,target(x,y,z),fov}"
    - "mode: 'macro'|'meso'|'micro'"
    - "filters: {points:boolean,lines:boolean,aux:boolean}"
    - "runtime.isFramePlaying: boolean"
    - "runtime.isCameraAuto: boolean"
    - "visibleSet: Set<string>"
    - "microState: MicroFXPayload | null"
    - "viewerSettings: object"



- name: runtime/core/structIndex.js
  layer: core
  responsibility:
    - "3DSS document から uuid インデックスと frameRange を構築する"
  exports:
    - name: buildUUIDIndex
      signature: "(document) → { uuidToKind:Map<uuid,kind>, ... }"
    - name: detectFrameRange
      signature: "(document) → {min:number,max:number}"
  called_by:
    - "bootstrapViewer"
    - "visibilityController"
    - "selectionController"
    - "microController"



- name: runtime/core/pointerInput.js
  layer: core
  responsibility:
    - "canvas 上の Pointer（Mouse/Wheel）入力を hub.core.camera / hub.pickObjectAt にマッピングする runtime 入力レイヤ"
  exports:
    - name: PointerInput
      type: class
      constructor: "(canvas:HTMLCanvasElement, cameraEngine:CameraEngine, hub) → PointerInput"
      methods:
        - dispose()
  calls:
    - "hub.core.camera.rotate"
    - "hub.core.camera.pan"
    - "hub.core.camera.zoom"
    - "hub.pickObjectAt"
    - "hub.core.selection.set"
    - "hub.core.mode.set"
  called_by:
    - "runtime/bootstrapViewer.js"
  constraints:
    - "UI（viewerDevHarness / 本番 host）は PointerInput を直接 new してはならない（bootstrapViewer に委譲）"
    - "CameraEngine に直接触らず、必ず hub.core.camera.* 経由にする（移行中は cameraEngine 直叩きの互換コードが残る場合がある）"



- name: runtime/core/keyboardInput.js
  layer: core
  responsibility:
    - "window の keydown を 1 箇所に集約し、core.camera / core.frame / core.mode / core.selection だけを叩く"
  exports:
    - name: KeyboardInput
      type: class
      constructor: "(target:Window, hub) → KeyboardInput"
      methods:
        - dispose()
  calls:
    - "hub.core.frame.step"
    - "hub.core.frame.range"
    - "hub.core.mode.set"
    - "hub.core.mode.get"
    - "hub.core.selection.get"
    - "hub.core.camera.rotate"
    - "hub.core.camera.zoom"
    - "hub.core.camera.reset"
  keymap:
    - "PageUp:   frame.step(+1)"
    - "PageDown: frame.step(-1)"
    - "Q / q:    selection.get().uuid があれば mode.set('micro', uuid)"
    - "W / w:    selection.get().uuid があれば mode.set('meso', uuid)"
    - "Esc:      mode.set('macro')"
    - "Home:     camera.reset()"
    - "+ / NumpadAdd:      camera.zoom(-0.1)"
    - "- / NumpadSubtract: camera.zoom(+0.1)"
    - "ArrowLeft/Right/Up/Down: camera.rotate(±Δθ,±Δφ)（Shift で倍速）"
  called_by:
    - "runtime/bootstrapViewer.js"
  constraints:
    - "INPUT / TEXTAREA / contentEditable にフォーカスがある場合はキーを無視する"
    - "UI からは KeyboardInput を直接 new してはならない（bootstrapViewer に委譲）"



# =========================
# 2.4 renderer
# =========================
- name: runtime/renderer/context.js
  layer: renderer
  responsibility:
    - "three.js renderer / scene / camera を初期化し、Core から渡された状態を描画する"
  exports:
    - name: createRendererContext
      returns: rendererContext
    - name: rendererContext
      methods:
        - syncDocument(document, indices)
        - getSceneMetrics(): "{center:{x,y,z}, radius:number} | null"
        - applyFrame(visibleSet)
        - updateCamera(cameraState)
        - applyMicroFX(microState)
        - applySelection(selectionState)
        - setHighlight(payload)
        - clearAllHighlights()
        - pickObjectAt(ndcX:number, ndcY:number): {uuid, distance, point} | null
        - render()
  internal_state:
    - "renderer: THREE.WebGLRenderer"
    - "scene: THREE.Scene"
    - "camera: THREE.PerspectiveCamera"
    - "lights: AmbientLight + DirectionalLight"
    - "pointObjects: Map<uuid,THREE.Object3D>"
    - "lineObjects: Map<uuid,THREE.Object3D>"
    - "auxObjects: Map<uuid,THREE.Object3D>"
    - "baseStyle: Map<uuid,{color:THREE.Color,opacity:number}>"
    - "raycaster: THREE.Raycaster"
  lifecycle:
    init:
      - "new THREE.WebGLRenderer({ canvas, antialias:true })"
      - "renderer.setPixelRatio(window.devicePixelRatio || 1)"
      - "renderer.setSize(canvas.clientWidth, canvas.clientHeight, false)"
      - "scene = new THREE.Scene()"
      - "camera = new THREE.PerspectiveCamera(fov, aspect, near, far)"
      - "scene に AmbientLight / DirectionalLight を追加"
    syncDocument:
      - "前回の point/line/aux オブジェクトを scene から remove & Map を clear"
      - "3DSS document の points/lines/aux から三次元オブジェクトを生成"
      - "各オブジェクトに userData.uuid を付与し、対応する Map に登録"
      - "baseStyle Map に元の color / opacity を保存"
    applyFrame:
      - "visibleSet: Set<uuid> を受け取り、各オブジェクトの obj.visible を更新"
    applyMicroFX:
      - "microState が null の場合: baseStyle に従って color/opacity をフルリセット"
      - "microState が MicroFXPayload の場合: focus / connection / distance などに応じて opacity / color を変更（詳細ロジックは任意だが 3DSS/struct は書き換えない）"
    updateCamera:
      - "camera.position / camera.up を cameraState から設定"
      - "target ベクトルに対して camera.lookAt(target)"
      - "fov が変わった場合は camera.fov 更新 ＋ updateProjectionMatrix()"
    applySelection:
      - "selectionState（{kind,uuid}）を受け取り、選択中要素の軽いハイライトを適用してもよい（必須ではない）"
    pickObjectAt:
      - "raycaster.setFromCamera({x:ndcX,y:ndcY}, camera)"
      - "raycaster.intersectObjects(scene.children, true) から userData.uuid を持つ最前面ヒットを返す"
    render:
      - "renderer.render(scene, camera)"
  calls: []
  called_by:
    - "bootstrapViewer（初期化）"
    - "runtime/viewerHub.js"
  constraints:
    - "3DSS document を書き換えてはならない"
    - "visibleSet / microState / selectionState / cameraState の canonical 所有者は core であり、renderer は各フレームで受け取って反映するだけ"
    - "mode や selection の判定ロジックを実装してはならない"
    - "UI layer は renderer を直接 import してはならない（pickObjectAt も必ず viewerHub.pickObjectAt 経由）"



# =========================
# 2.5 UI Bridge
# =========================
# Pointer/Keyboard 入力は runtime/core に移したため、
# UI 層は「DOM UI → hub.core.* / hub.pickObjectAt」のみを担当する。

- name: ui/gizmo.js
  layer: ui
  responsibility:
    - "画面右下の HUD 軸ギズモを描画し、クリックで camera snap/home を呼ぶ"
  exports:
    - name: attachGizmo
      signature: "(wrapperElement:HTMLElement, hub) → void"
  calls:
    - runtime/viewerHub.core.camera.snapToAxis
    - runtime/viewerHub.core.camera.reset
  constraints:
    - "three.js 本体の scene には入らず、HUD overlay として DOM で描画する"



- name: ui/picker.js
  layer: ui
  responsibility:
    - "canvas 上のクリック座標から uuid を取得し、selection を更新する"
  exports:
    - name: createPicker
      returns: picker
    - name: picker
      methods:
        - attach(domElement)
        - detach()
  calls:
    - runtime/viewerHub.pickObjectAt
    - runtime/viewerHub.core.selection.set
  called_by:
    - "Host UI 初期化コード（または viewerDevHarness）"



- name: ui/timeline.js
  layer: ui
  responsibility:
    - "frame scrub / play/pause UI と core.frame.* を接続する（dev harness に一体化してもよい）"
  exports:
    - name: createTimeline
      returns: timeline
  calls:
    - runtime/viewerHub.core.frame.set
    - runtime/viewerHub.core.frame.step
    - runtime/viewerHub.core.frame.range
  called_by:
    - "Host UI 初期化コード"
```

# =========================================================

# 3. Runtime フロー

# =========================================================

runtime_flow:
startup:
- "Host が bootstrapViewerFromUrl(canvas, url, options) or bootstrapViewer(canvas, doc, options) を呼ぶ"
- "bootstrapViewer が JSON load → AJV validate → deepFreeze(document) → uiState / indices / rendererContext / viewerHub を生成"
- "bootstrapViewer が PointerInput(canvas, cameraEngine, hub) / KeyboardInput(window, hub) を構築し、入力イベントを runtime 内に集約する"
- "options.devBootLog === true かつ options.logger がある場合、起動診断ログ（BOOT/MODEL/CAMERA/LAYERS/FRAME）を logger に 1 回ずつ送る"
- "Host / dev harness が gizmo / timeline / HUD 等の ui/* を初期化し、hub.core.* / hub.pickObjectAt にイベントを接続する"

```
frame_update:
  - "UI（slider / ボタン / KeyboardInput の PgUp/PgDn）が hub.core.frame.set / step を呼ぶ"
  - "core.frameController が activeFrame を更新し、visibilityController.recompute() で uiState.visibleSet を更新"
  - "必要に応じて microController.refresh() が呼ばれ、uiState.microState を再計算する"
  - "次フレームの hub tick で renderer.applyFrame(uiState.visibleSet) および renderer.applyMicroFX(uiState.microState) が呼ばれる"

selection_update:
  - "PointerInput / ui picker が canvas 座標から NDC 座標を計算し、hub.pickObjectAt(ndcX, ndcY) を呼ぶ"
  - "viewerHub が renderer.pickObjectAt を呼び、{uuid,...} を返す"
  - "selector が hub.core.selection.set({uuid,kind}) を呼ぶ"
  - "selectionController が uiState.selection を更新"
  - "modeController が必要なら micro/meso へ遷移し、microController.compute() → uiState.microState を更新"
  - "次フレームの hub tick で renderer.applyMicroFX(uiState.microState) が呼ばれる"

render_loop:
  - "viewerHub.start() が内部で requestAnimationFrame ループを開始"
  - "各フレーム tick で:"
  - "  1) renderer.updateCamera(core.cameraEngine.getState() または uiState.cameraState)"
  - "  2) renderer.applyFrame(uiState.visibleSet)"
  - "  3) renderer.applyMicroFX(uiState.microState)"
  - "  4) renderer.applySelection(uiState.selection)（必要なら）"
  - "  5) renderer.render()"
```
