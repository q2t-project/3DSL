runtime_spec:

  version: "2.1-draft"

  description: "3DSL Viewer Runtime Manifest – holy API spec for 3DSL Viewer"

  # =========================================================
  # 0. レイヤ定義 ＋ 依存ルール
  # =========================================================

  layers:
    - name: entry
      description: "Host（Astro/HTML）から叩かれるエントリポイント層"
    - name: hub
      description: "UI と core / renderer の集線層（ロジック禁止）"
    - name: core
      description: "状態とビジネスロジックの中枢。3DSS は read-only"
    - name: renderer
      description: "three.js による描画専用。state-less 指向"
    - name: ui
      description: "UI イベント → hub.core.* への橋渡し層（dev harness / 本番 host 側）"

  dependency_rules:
    # 正方向
    - "ui        → hub       → core      → renderer"

    # 禁止方向（絶対）
    - "core      → hub:       FORBIDDEN"
    - "renderer  → core:      FORBIDDEN"
    - "renderer  → hub:       FORBIDDEN"
    - "hub       → ui:        FORBIDDEN"
    - "ui        → renderer:  FORBIDDEN（pick も hub 経由）"

  # =========================================================
  # 1. state 所有権
  # =========================================================

  ownership:
    uiState:        "core"
    visibleSet:     "core"
    microState:     "core"
    cameraState:    "core"
    document_3dss:  "core (immutable)"
    three_objects:  "renderer"

  # =========================================================
  # 2. モジュール一覧
  # =========================================================

  modules:

    # =========================
    # 2.1 entry
    # =========================
    - name: runtime/bootstrapViewer.js
      layer: entry
      responsibility:
        - "canvas と strict validation 済み 3DSS オブジェクトを受け取り、runtime 一式を初期化する"
        - "（bootstrapViewerFromUrl のみ）URL から JSON をロードし、AJV で strict validate する"
        - "core / renderer / viewerHub を生成して返す"
        - "描画ループ開始は行わず、返却した hub.start() に委譲する"
        - "入力系（PointerInput / KeyboardInput / gizmo 等）は構築せず、Host / dev harness 側の責務とする"
        - "（dev オプションが指定された場合）起動診断ログ（BOOT/MODEL/CAMERA/LAYERS/FRAME）を発行する"
      exports:
        - name: bootstrapViewer
          signature: "(canvasOrId, threeDSS, options?) → hub"
        - name: bootstrapViewerFromUrl
          signature: "(canvasOrId, url, options?) → Promise<hub>"
        - name: ViewerBootstrapOptions
          fields:
            - name: devBootLog
              type: "boolean"
              description: |
                起動時に BOOT/MODEL/CAMERA/LAYERS/FRAME の 5 レコードを発行するかどうか。
                true のときのみ logger に渡す。
            - name: devLabel
              type: "string"
              description: "BOOT ログに載せるラベル（例: 'viewer_dev' / 'viewer_embed'）"
            - name: modelUrl
              type: "string"
              description: "MODEL ログ payload に載せる識別子（URL または任意ラベル）"
            - name: logger
              type: "(line:string) => void"
              description: "devBootLog 出力先（未指定時は console.log 相当にフォールバックしてもよい）"
      calls:
        - runtime/core/uiState.createUiState
        - runtime/core/structIndex.buildUUIDIndex
        - runtime/core/structIndex.detectFrameRange
        - runtime/core/cameraEngine.CameraEngine (constructor)
        - runtime/core/frameController.createFrameController
        - runtime/core/selectionController.createSelectionController
        - runtime/core/microController.createMicroController
        - runtime/core/visibilityController.createVisibilityController
        - runtime/core/modeController.createModeController
        - runtime/core/deepFreeze.deepFreeze
        - runtime/core/validator.initValidator
        - runtime/core/validator.validate3DSS
        - runtime/renderer/context.createRendererContext
        - runtime/viewerHub.createViewerHub
      called_by:
        - "Host（Astro / HTML 側の起動コード / viewerDevHarness）"
      constraints:
        - "描画ループ（requestAnimationFrame）は持たない。hub.start に任せる"
        - "ui/* モジュールを import してはならない"
        - "3DSS が AJV で NG の場合は hub を生成せず Error を投げる"
        - "3DSS document は deepFreeze 済み immutable とみなす"
        - "bootstrapViewer は strict validation 済み 3DSS オブジェクトだけを受け取る（JSON load と validate は host / bootstrapViewerFromUrl 側の責務）"
        - "PointerInput / KeyboardInput は構築しない（入力系は Host / dev harness が new する）"

    # =========================
    # 2.2 hub
    # =========================
    - name: runtime/viewerHub.js
      layer: hub
      responsibility:
        - "core と renderer を束ねて、UI に対して hub.core.* API を提供する"
        - "render loop（hub.start / hub.stop）を 1 箇所で管理する"
        - "UI からの呼び出しはすべて hub.core.* / hub.pickObjectAt に統一する"
      exports:
        - name: createViewerHub
          signature: "({ core, renderer }) → hub"
        - name: hub
          children:
            - core
            - start
            - stop
            - pickObjectAt
      hub_shape:
        core:
          props:
            - name: data
              description: "struct（3DSS document）。deep-freeze 済み、read-only。"
            - name: uiState
              description: "uiState オブジェクトそのもの。更新は core.* / controller 経由のみ許可。"
            - name: frame
              description: "frameController への公開ラッパ (setActive/getActive/next/prev/getRange)。"
            - name: camera
              description: "CameraEngine への公開ラッパ (rotate/pan/zoom/reset/snapToAxis/…）。"
            - name: mode
              description: "modeController への公開ラッパ。"
            - name: selection
              description: "selectionController への公開ラッパ。"
            - name: filters
              description: "visibilityController の filters ラッパ。"
            - name: visibilityController
              description: "visibleSet 再計算の唯一の正規ルート。"
            - name: microController
              description: "microState 計算用 controller。"
            - name: frameController
              description: "frame 用 controller 本体（互換用）。"
            - name: cameraEngine
              description: "CameraEngine 本体（互換用）。"
      calls:
        - "core/frameController.*"
        - "core/selectionController.*"
        - "core/modeController.*"
        - "core/microController.*"
        - "core/visibilityController.*"
        - "core/cameraEngine.*"
        - "renderer/context.applyFrame"
        - "renderer/context.applyMicroFX"
        - "renderer/context.updateCamera"
        - "renderer/context.applySelection"
        - "renderer/context.setHighlight"
        - "renderer/context.clearAllHighlights"
        - "renderer/context.pickObjectAt"
        - "renderer/context.render"
      called_by:
        - "ui/pointerInput.js"
        - "ui/keyboardInput.js"
        - "ui/gizmo.js"
        - "ui/picker.js"
        - "ui/timeline.js（将来の独立タイムライン UI を想定）"
        - "viewerDevHarness.js（dev viewer 専用 UI）"
      constraints:
        - "frame/mode/micro/selection の判定ロジックを hub に書いてはならない。必ず core.* に委譲する"
        - "three.js のオブジェクトや material を直接触ってはならない"
        - "3DSS document を直接変更してはならない"

      core_api:

        frame:
          - name: setActive
            signature: "(frame:number|null) → void"
            calls:
              - core/frameController.setActive

          - name: getActive
            signature: "() → number|null"
            calls:
              - core/frameController.getActive

          - name: next
            signature: "() → void"
            calls:
              - core/frameController.step(+1)

          - name: prev
            signature: "() → void"
            calls:
              - core/frameController.step(-1)

          - name: getRange
            signature: "() → {min:number,max:number} | null"
            calls:
              - core/frameController.getRange

        selection:
          - name: select
            signature: "(payload:{uuid:string,kind:'points'|'lines'|'aux'}) → void"
            calls:
              - core/selectionController.select

          - name: clear
            signature: "() → void"
            calls:
              - core/selectionController.clear

          - name: get
            signature: "() → {kind:'points'|'lines'|'aux'|null, uuid:string|null}"
            calls:
              - core/selectionController.get

          - name: setHover
            signature: "(payload:{uuid:string|null,kind:'points'|'lines'|'aux'|null}) → void"
            calls:
              - core/selectionController.setHover

          - name: getHover
            signature: "() → {kind:'points'|'lines'|'aux'|null, uuid:string|null}"
            calls:
              - core/selectionController.getHover

        camera:
          - name: rotate
            signature: "(dTheta:number, dPhi:number) → void"
            calls:
              - core/cameraEngine.rotate

          - name: pan
            signature: "(dx:number, dy:number) → void"
            calls:
              - core/cameraEngine.pan

          - name: zoom
            signature: "(delta:number) → void"
            calls:
              - core/cameraEngine.zoom

          - name: reset
            signature: "() → void"
            calls:
              - core/cameraEngine.reset

          - name: snapToAxis
            signature: "(axis:'x'|'y'|'z') → void"
            calls:
              - core/cameraEngine.snapToAxis

          - name: setFOV
            signature: "(value:number) → void"
            calls:
              - core/cameraEngine.setFOV

          - name: setState
            signature: "(partialState:object) → void"
            calls:
              - core/cameraEngine.setState

          - name: getState
            signature: "() → cameraState"
            calls:
              - core/cameraEngine.getState

        mode:
          - name: setMode
            signature: "(mode:'macro'|'meso'|'micro', uuid?:string) → 'macro'|'meso'|'micro'"
            calls:
              - core/modeController.setMode

          - name: getMode
            signature: "() → 'macro'|'meso'|'micro'"
            calls:
              - core/modeController.getMode

          - name: exit
            signature: "() → void"
            calls:
              - core/modeController.exit

        micro:
          - name: canEnter
            signature: "(uuid:string) → boolean"
            calls:
              - core/modeController.canEnter

          - name: enter
            signature: "(uuid:string) → void"
            calls:
              - core/modeController.setMode('micro', uuid)

          - name: exit
            signature: "() → void"
            calls:
              - core/modeController.exit

          - name: isActive
            signature: "() → boolean"
            impl_note: "uiState.mode === 'micro' を見るだけ（core 所有）"

        filters:
          - name: setTypeEnabled
            signature: "(kind:'points'|'lines'|'aux', enabled:boolean) → void"
            calls:
              - core/visibilityController.setTypeEnabled

          - name: setAuxModuleEnabled
            signature: "(module:string, enabled:boolean) → void"
            calls:
              - core/visibilityController.setAuxModuleEnabled

          - name: get
            signature: "() → FiltersState"
            calls:
              - core/visibilityController.get

        runtime:
          # 再生制御については現状 dev harness 側実装としつつ、
          # API 名だけは runtime 側に予約しておく。
          - name: startFramePlayback
            signature: "() → void"
            impl_note: "uiState.runtime.isFramePlaying = true にし、必要なら内部タイマーを開始する。v1 では dev harness 側実装でもよい。"

          - name: stopFramePlayback
            signature: "() → void"
            impl_note: "uiState.runtime.isFramePlaying = false にし、内部タイマーを止める。"

          - name: isFramePlaying
            signature: "() → boolean"
            impl_note: "uiState.runtime.isFramePlaying を返す。"

          - name: isCameraAuto
            signature: "() → boolean"
            impl_note: "uiState.runtime.isCameraAuto を返す（将来の自動カメラ用）。"

    # =========================
    # 2.3 core
    # =========================
    - name: runtime/core/cameraEngine.js
      layer: core
      responsibility:
        - "cameraState を内部に保持し、renderer に渡すための状態を作る"
      exports:
        - name: CameraEngine
          type: class
          methods:
            - rotate(dTheta:number, dPhi:number)
            - pan(dx:number, dy:number)
            - zoom(delta:number)
            - reset()
            - snapToAxis(axis:'x'|'y'|'z')
            - setState(partialState:object)
            - getState(): cameraState
            - setFOV(value:number)
      calls: []
      called_by:
        - "runtime/viewerHub.js（core.camera.* 経由）"
        - "core/modeController.js（フォーカス遷移時に参照する場合があれば）"
      state:
        - "cameraState を内部に保持する"
        - "three.js の Camera インスタンスは renderer が保持し、この state を反映するだけ"

    - name: runtime/core/frameController.js
      layer: core
      responsibility:
        - "active frame を管理する"
        - "frameRange を決定し、uiState.frame に保持する"
      exports:
        - name: createFrameController
          returns: frameController
        - name: frameController
          methods:
            - setActive(frame:number|null)
            - getActive(): number|null
            - step(delta:number)
            - getRange(): {min:number,max:number} | null
      calls:
        - core/visibilityController.recompute
      called_by:
        - "runtime/viewerHub.js（core.frame.* 経由）"
        - "KeyboardInput（PgUp/PgDn）"
      state:
        - "activeFrame と frameRange を uiState.frame に保持する"

    - name: runtime/core/selectionController.js
      layer: core
      responsibility:
        - "現在の選択要素（kind, uuid）および hover 状態を管理する"
      exports:
        - name: createSelectionController
          returns: selectionController
        - name: selectionController
          methods:
            - select(payload:{uuid:string,kind:'points'|'lines'|'aux'})
            - clear()
            - get(): {kind:'points'|'lines'|'aux'|null, uuid:string|null}
            - setHover(payload:{uuid:string|null,kind:'points'|'lines'|'aux'|null})
            - getHover(): {kind:'points'|'lines'|'aux'|null, uuid:string|null}
      calls:
        - core/structIndex.buildUUIDIndex（が作った index を参照）
      called_by:
        - "runtime/viewerHub.js（core.selection.*）"
        - "core/modeController.js"
      state:
        - "uiState.selection = {kind, uuid} を更新する"
        - "uiState.hover = {kind, uuid} を更新する（hover 機能を採用する場合）"

    - name: runtime/core/modeController.js
      layer: core
      responsibility:
        - "mode（macro/meso/micro）と micro 侵入条件の優先ルールを管理する"
      exports:
        - name: createModeController
          returns: modeController
        - name: modeController
          methods:
            - setMode(mode:'macro'|'meso'|'micro', uuid?:string)
            - getMode(): 'macro'|'meso'|'micro'
            - canEnter(uuid:string): boolean
            - exit()
      calls:
        - core/selectionController.select
        - core/selectionController.get
        - core/microController.compute
        - core/frameController.getActive
        - core/visibilityController.isVisible
      called_by:
        - "runtime/viewerHub.js（core.mode.*, core.micro.*）"
        - "KeyboardInput（Q/W/Esc）"
      rules:
        - "frame 再生（将来実装する場合）開始時は必ず mode='macro' に戻す"
        - "micro/meso は visibleSet 内の要素にだけ適用される"
        - "canEnter は isFramePlaying / isCameraAuto / visibleSet をチェックする"
      state:
        - "uiState.mode を更新する"
        - "uiState.microState を microController.compute の結果で更新する"

    - name: runtime/core/microController.js
      layer: core
      responsibility:
        - "selection + cameraState + structIndex から microState（= MicroFXPayload）を算出する"
      exports:
        - name: createMicroController
          returns: microController
        - name: microController
          methods:
            - compute(selection, cameraState, struct): MicroFXPayload | null
            - refresh(): void
      calls:
        - core/structIndex（uuid→kind / 近傍情報などを参照）
      called_by:
        - "core/modeController"
        - "core.recomputeVisibleSet()（bootstrapViewer が core にぶら下げる補助メソッド）"
      constraints:
        - "three.js を import してはならない"
        - "renderer に直接アクセスしてはならない"
      microState_shape:
        - "MicroFXPayload 型（3DSD-viewer.md 7.11 節）と同型のオブジェクト、または null を返す"
        - "renderer は unknown なフィールドは無視して良い"

    - name: runtime/core/visibilityController.js
      layer: core
      responsibility:
        - "appearance.visible / frames / filters を合成し、visibleSet を計算する"
      exports:
        - name: createVisibilityController
          returns: visibilityController
        - name: visibilityController
          methods:
            - recompute(): visibleSet
            - isVisible(uuid:string): boolean
            - get(): FiltersState
            - setTypeEnabled(kind:'points'|'lines'|'aux', enabled:boolean)
            - setAuxModuleEnabled(module:string, enabled:boolean)
      calls: []
      called_by:
        - "runtime/viewerHub.js（core.filters.*）"
        - "core/frameController"
        - "core/modeController"
      state:
        - "uiState.visibleSet を Set<uuid> として保持する"
        - "uiState.filters を {points,lines,aux,auxModules?:Record<string,boolean>} として保持する"

    - name: runtime/core/uiState.js
      layer: core
      responsibility:
        - "viewer の UI 状態を一元管理する（document とは分離）"
      exports:
        - name: createUiState
          returns: uiState
      fields:
        - "frame.current: number|null"
        - "frame.range: {min:number,max:number} | null"
        - "selection: {kind:'points'|'lines'|'aux'|null, uuid:string|null}"
        - "hover: {kind:'points'|'lines'|'aux'|null, uuid:string|null}"
        - "cameraState: {theta,phi,distance,target(x,y,z),fov}"
        - "mode: 'macro'|'meso'|'micro'"
        - "filters: {points:boolean,lines:boolean,aux:boolean,auxModules?:Record<string,boolean>}"
        - "runtime.isFramePlaying: boolean"
        - "runtime.isCameraAuto: boolean"
        - "visibleSet: Set<string>"
        - "microState: MicroFXPayload | null"
        - "viewerSettings: object"

    - name: runtime/core/structIndex.js
      layer: core
      responsibility:
        - "3DSS document から uuid インデックスと frameRange を構築する"
      exports:
        - name: buildUUIDIndex
          signature: "(document) → { uuidToKind:Map<uuid,kind>, ... }"
        - name: detectFrameRange
          signature: "(document) → {min:number,max:number}"
      called_by:
        - "bootstrapViewer"
        - "visibilityController"
        - "selectionController"
        - "microController"

    # =========================
    # 2.4 renderer
    # =========================
    - name: runtime/renderer/context.js
      layer: renderer
      responsibility:
        - "three.js renderer / scene / camera を初期化し、Core から渡された状態を描画する"
      exports:
        - name: createRendererContext
          returns: rendererContext
        - name: rendererContext
          methods:
            - syncDocument(document, indices)
            - getSceneMetrics(): "{center:{x,y,z}, radius:number} | null"
            - applyFrame(visibleSet)
            - updateCamera(cameraState)
            - applyMicroFX(microState)
            - applySelection(selectionState)
            - setHighlight(payload)
            - clearAllHighlights()
            - pickObjectAt(ndcX:number, ndcY:number): {uuid, distance, point} | null
            - render()
      internal_state:
        - "renderer: THREE.WebGLRenderer"
        - "scene: THREE.Scene"
        - "camera: THREE.PerspectiveCamera"
        - "lights: AmbientLight + DirectionalLight"
        - "pointObjects: Map<uuid,THREE.Object3D>"
        - "lineObjects: Map<uuid,THREE.Object3D>"
        - "auxObjects: Map<uuid,THREE.Object3D>"
        - "baseStyle: Map<uuid,{color:THREE.Color,opacity:number}>"
        - "raycaster: THREE.Raycaster"
      lifecycle:
        init:
          - "new THREE.WebGLRenderer({ canvas, antialias:true })"
          - "renderer.setPixelRatio(window.devicePixelRatio || 1)"
          - "renderer.setSize(canvas.clientWidth, canvas.clientHeight, false)"
          - "scene = new THREE.Scene()"
          - "camera = new THREE.PerspectiveCamera(fov, aspect, near, far)"
          - "scene に AmbientLight / DirectionalLight を追加"
        syncDocument:
          - "前回の point/line/aux オブジェクトを scene から remove & Map を clear"
          - "3DSS document の points/lines/aux から三次元オブジェクトを生成"
          - "各オブジェクトに userData.uuid を付与し、対応する Map に登録"
          - "baseStyle Map に元の color / opacity を保存"
        applyFrame:
          - "visibleSet: Set<uuid> を受け取り、各オブジェクトの obj.visible を更新"
        applyMicroFX:
          - "microState が null の場合: baseStyle に従って color/opacity をフルリセット"
          - "microState が MicroFXPayload の場合: focus / connection / distance などに応じて opacity / color を変更（詳細ロジックは任意だが 3DSS/struct は書き換えない）"
        updateCamera:
          - "camera.position / camera.up を cameraState から設定"
          - "target ベクトルに対して camera.lookAt(target)"
          - "fov が変わった場合は camera.fov 更新 ＋ updateProjectionMatrix()"
        applySelection:
          - "selectionState（{kind,uuid}）を受け取り、選択中要素の軽いハイライトを適用してもよい（必須ではない）"
        setHighlight:
          - "指定 uuid の要素を強調する selection ハイライトを適用する（7.12 節）。"
        clearAllHighlights:
          - "現在の visibleSet に含まれる要素の baseStyle を復元し、selection ハイライトをリセットする。"
        pickObjectAt:
          - "raycaster.setFromCamera({x:ndcX,y:ndcY}, camera)"
          - "raycaster.intersectObjects(scene.children, true) から userData.uuid を持つ最前面ヒットを返す"
        render:
          - "renderer.render(scene, camera)"
      calls: []
      called_by:
        - "bootstrapViewer（初期化）"
        - "runtime/viewerHub.js"
      constraints:
        - "3DSS document を書き換えてはならない"
        - "visibleSet / microState / selectionState / cameraState の canonical 所有者は core であり、renderer は各フレームで受け取って反映するだけ"
        - "mode や selection の判定ロジックを実装してはならない"
        - "UI layer は renderer を直接 import してはならない（pickObjectAt も必ず viewerHub.pickObjectAt 経由）"

    # =========================
    # 2.5 UI Bridge
    # =========================
    # Pointer/Keyboard 入力も含めて、
    # UI 層は「DOM 入力 / UI → hub.core.* / hub.pickObjectAt」のみを担当する。

    - name: ui/gizmo.js
      layer: ui
      responsibility:
        - "画面右下の HUD 軸ギズモを描画し、クリックで camera snap/home を呼ぶ"
      exports:
        - name: attachGizmo
          signature: "(wrapperElement:HTMLElement, hub) → void"
      calls:
        - runtime/viewerHub.core.camera.snapToAxis
        - runtime/viewerHub.core.camera.reset
      constraints:
        - "three.js 本体の scene には入らず、HUD overlay として DOM で描画する"

    - name: ui/picker.js
      layer: ui
      responsibility:
        - "canvas 上のクリック座標から uuid を取得し、selection を更新する"
      exports:
        - name: createPicker
          returns: picker
        - name: picker
          methods:
            - attach(domElement)
            - detach()
      calls:
        - runtime/viewerHub.pickObjectAt
        - runtime/viewerHub.core.selection.select
      called_by:
        - "Host UI 初期化コード（または viewerDevHarness）"

    - name: ui/timeline.js
      layer: ui
      responsibility:
        - "frame scrub / play/pause UI と core.frame.* を接続する（dev harness に一体化してもよい）"
      exports:
        - name: createTimeline
          returns: timeline
      calls:
        - runtime/viewerHub.core.frame.setActive
        - runtime/viewerHub.core.frame.next
        - runtime/viewerHub.core.frame.prev
        - runtime/viewerHub.core.frame.getRange
        - runtime/viewerHub.core.runtime.startFramePlayback
        - runtime/viewerHub.core.runtime.stopFramePlayback
      called_by:
        - "Host UI 初期化コード"

    - name: ui/pointerInput.js
      layer: ui
      responsibility:
        - "canvas 上の Pointer（Mouse/Wheel）入力を hub.core.camera / hub.pickObjectAt にマッピングする UI 入力レイヤ"
      exports:
        - name: PointerInput
          type: class
          constructor: "(canvas:HTMLCanvasElement, hub) → PointerInput"
          methods:
            - dispose()
      calls:
        - "hub.core.camera.rotate"
        - "hub.core.camera.pan"
        - "hub.core.camera.zoom"
        - "hub.pickObjectAt"
        - "hub.core.selection.select"
        - "hub.core.mode.setMode"
      called_by:
        - "viewerDevHarness.js"
        - "本番 Host の UI 初期化コード（必要な場合）"
      constraints:
        - "runtime/core からは PointerInput を import してはならない（UI 専用）"
        - "CameraEngine に直接触らず、原則として hub.core.camera.* 経由で操作する（移行中は cameraEngine 直叩きの互換コードが残る場合がある）"

    - name: ui/keyboardInput.js
      layer: ui
      responsibility:
        - "window の keydown を 1 箇所に集約し、hub.core.camera / hub.core.frame / hub.core.mode / hub.core.selection だけを叩く"
      exports:
        - name: KeyboardInput
          type: class
          constructor: "(target:Window, hub) → KeyboardInput"
          methods:
            - dispose()
      calls:
        - "hub.core.frame.next"
        - "hub.core.frame.prev"
        - "hub.core.frame.getRange"
        - "hub.core.mode.setMode"
        - "hub.core.mode.getMode"
        - "hub.core.selection.get"
        - "hub.core.camera.rotate"
        - "hub.core.camera.zoom"
        - "hub.core.camera.reset"
      keymap:
        - "PageUp:   frame.next()"
        - "PageDown: frame.prev()"
        - "Q / q:    selection.get().uuid があれば mode.setMode('micro', uuid)"
        - "W / w:    （v1 では UI から meso へは入らないため予約）"
        - "Esc:      mode.setMode('macro')"
        - "Home:     camera.reset()"
        - "+ / NumpadAdd:      camera.zoom(-0.1)"
        - "- / NumpadSubtract: camera.zoom(+0.1)"
        - "ArrowLeft/Right/Up/Down: camera.rotate(±Δθ,±Δφ)（Shift で倍速）"
      called_by:
        - "viewerDevHarness.js"
        - "本番 Host の UI 初期化コード（必要な場合）"
      constraints:
        - "INPUT / TEXTAREA / contentEditable にフォーカスがある場合はキーを無視する"
        - "runtime/core からは KeyboardInput を import してはならない（UI 専用）"

  # =========================================================
  # 3. Runtime フロー
  # =========================================================

  runtime_flow:
    startup:
      - "Host が bootstrapViewerFromUrl(canvas, url, options) or bootstrapViewer(canvas, doc, options) を呼ぶ"
      - "bootstrapViewerFromUrl が JSON load → AJV validate → deepFreeze(document) を行い、strict validation 済み 3DSS を bootstrapViewer に渡す"
      - "bootstrapViewer が uiState / indices / rendererContext / viewerHub を生成する"
      - "options.devBootLog === true かつ options.logger がある場合、起動診断ログ（BOOT/MODEL/CAMERA/LAYERS/FRAME）を logger に 1 回ずつ送る"
      - "Host / dev harness が PointerInput(canvas, hub) / KeyboardInput(window, hub) を構築し、入力イベントを hub.core.* / hub.pickObjectAt に集約する"
      - "Host / dev harness が gizmo / timeline / HUD 等の ui/* を初期化し、hub.core.* / hub.pickObjectAt にイベントを接続する"
      - "Host / dev harness が hub.start() を 1 回だけ呼び、render loop を開始する"

    frame_update:
      - "UI（slider / ボタン / KeyboardInput の PgUp/PgDn）が hub.core.frame.setActive / next / prev を呼ぶ"
      - "core.frameController が activeFrame を更新し、visibilityController.recompute() で uiState.visibleSet を更新"
      - "必要に応じて microController.refresh() が呼ばれ、uiState.microState を再計算する"
      - "次フレームの hub tick で renderer.applyFrame(uiState.visibleSet) および renderer.applyMicroFX(uiState.microState) が呼ばれる"

    selection_update:
      - "PointerInput / ui picker が canvas 座標から NDC 座標を計算し、hub.pickObjectAt(ndcX, ndcY) を呼ぶ"
      - "viewerHub が renderer.pickObjectAt を呼び、{uuid,...} を返す"
      - "selector が hub.core.selection.select({uuid,kind}) を呼ぶ"
      - "selectionController が uiState.selection を更新"
      - "modeController が必要なら micro/meso へ遷移し、microController.compute() → uiState.microState を更新"
      - "次フレームの hub tick で renderer.applyMicroFX(uiState.microState) が呼ばれる"

    render_loop:
      - "viewerHub.start() が内部で requestAnimationFrame ループを開始"
      - "各フレーム tick で:"
      - "  1) renderer.updateCamera(core.cameraEngine.getState() または uiState.cameraState)"
      - "  2) renderer.applyFrame(uiState.visibleSet)"
      - "  3) renderer.applyMicroFX(uiState.microState)"
      - "  4) renderer.applySelection(uiState.selection)（必要なら）"
      - "  5) renderer.render()"
