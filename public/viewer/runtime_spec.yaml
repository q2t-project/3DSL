runtime_spec:

  version: "2.2-draft"

  description: "3DSL Viewer Runtime Manifest – holy API spec for 3DSL Viewer"

  # =========================================================
  # 0. レイヤ定義 ＋ 依存ルール
  # =========================================================

  layers:
    - name: entry
      description: "Host（Astro/HTML）から叩かれるエントリポイント層"
    - name: hub
      description: "UI と core / renderer の集線層（ロジック禁止）"
    - name: core
      description: "状態とビジネスロジックの中枢。3DSS は read-only"
    - name: renderer
      description: "three.js による描画専用。状態は描画キャッシュに限定（canonical state は core）"
    - name: ui
      description: "UI イベント → hub.core.* への橋渡し層（dev harness / 本番 host 側）"

  dependency_rules:
    # 正方向
    - "ui        → entry"
    - "entry     → hub"
    - "entry     → core"
    - "entry     → renderer"
    - "ui        → hub"
    - "hub       → core"
    - "hub       → renderer"

    # 禁止方向（絶対）
    - "core      → hub:       FORBIDDEN"
    - "core      → renderer:  FORBIDDEN"
    - "renderer  → core:      FORBIDDEN"
    - "renderer  → hub:       FORBIDDEN"
    - "hub       → ui:        FORBIDDEN"
    - "ui        → renderer:  FORBIDDEN（pick も hub 経由）"
    - "entry     → ui:        FORBIDDEN（UI は Host 側責務）"

  # =========================================================
  # 0.2 DI（依存注入）方針と calls 表記ルール
  # =========================================================

  di_policy:
    principle:
      - "core 内の相互参照は import で結ばない。bootstrapViewer を composition root として DI で渡す。"
      - "hub は { core, renderer } を DI で受け取り、core/* や renderer/* を import しない。"
      - "core の各モジュールは 'factory + injected deps' で完結させる。createXxx は必要依存（関数/参照/値）を **すべて引数オブジェクトで受け取る**。"
      - "calls 記法は仕様の規範であり、実装はこれに従う（曖昧さを残さない）。"
      - "禁止: core/* が他の core/* を import して呼ぶ。例外として JSDoc の型参照 **のみ** は許容する（例: /** @typedef {import('./x.js').Foo} Foo */）。※ ESM の実行時 import（import {Foo} from ...）は例外に含めない。"
      - "helper（local helper）は **同一ファイル内に閉じる純関数** とし、他モジュールから import してはならない。"
    contract_gates:
      - "scripts/check-invariants.mjs: 依存方向（forbidden imports）を強制"
      - "scripts/check-phase2-contract.mjs: bootstrapViewer 公開面の整合"
      - "scripts/check-phase2-core-contract.mjs: core 公開面（controller群/recomputeVisibleSet）の整合"
      - "grep-based single-writer check（推奨）: uiState.visibleSet / uiState.runtime.isFramePlaying の書き込み箇所を固定"
    calls_notation:
      - "calls: 'IMPORT:' は当該モジュールが import して直接呼ぶことを意味する（entry など）。"
      - "calls: 'DI:' は注入された依存（関数/参照/値）へのアクセスを意味する（呼び出し/参照の両方）。import を意味しない。"
      - "calls: 'CALL:' は当該モジュール内で行う **呼び出し式** を意味する（import 済み関数の呼び出し／ローカル関数／インスタンスメソッドを含む）。DI 経由の呼び出しも CALL で式を明記してよいが、その場合は対応する DI 行を必ず併記する（CALL だけは禁止）。"
      - "core 内で他 core モジュール機能を使う場合は必ず 'DI:' で表記する。"
    injection_trace:
      - "各 core モジュールは di_injected に注入元（source）を明記する（実装は引数 DI を推奨）。"

      
  # =========================================================
  # 0.3 ライフサイクル（start/stop/dispose）規約
  # =========================================================

  lifecycle_policy:
    - "hub.start()/hub.stop()/hub.dispose() は **idempotent**（複数回呼んでも安全）とする。"
    - "hub.stop(): RAF 停止のみ（WebGL 資源は保持）。"
    - "hub.dispose(): stop + renderer.dispose（資源解放）。hub は勝手に購読を作らないため、onXChanged の解除は呼び出し側が unsubscribe を保持して行う（再利用不可）。"
    - "rendererContext.dispose(): three.js 資源を可能な範囲で解放し、2回目以降は no-op（idempotent）とする。"
    - "onXChanged 系の listener 登録は unsubscribe を返す（dev harness で積み上げない）。"
    - "dispose 後の start/stop/resize は no-op。pickObjectAt は常に null を返す（例外にしない）。"
    - "dispose 後の isRunning() は常に false を返す。"

  # =========================================================
  # 1. state 所有権
  # =========================================================

  ownership:
    uiState:        "core"
    visibleSet:     "core (single-writer: core/recomputeVisibleSet only)"
    isFramePlaying: "core (single-writer: core/frameController only)"
    microState:     "core (single-writer: core/microController.refresh only)"
    cameraState:    "core"
    document_3dss:  "core (immutable)"
    three_objects:  "renderer"
    viewerSettings:
      canonical: "core (uiState.viewerSettings.render / uiState.viewerSettings.fx)"

  # =========================================================
  # 2. モジュール一覧
  # =========================================================

  modules:

    # =========================
    # 2.1 entry
    # =========================
    - name: runtime/bootstrapViewer.js
      layer: entry
      responsibility:
        - "canvas と 3DSS オブジェクトを受け取り、AJV validate3DSS を **常に** 実行して runtime 一式を初期化する（NGなら throw）"
        - "validateRefIntegrity は options.strictValidate=true または options.validateRefIntegrity=true のときのみ実行する"
        - "core / renderer / viewerHub を生成して返す"
        - "rendererContext.syncDocument(document, indices) を 1 回呼び、描画オブジェクトを構築する"
        - "rendererContext.getSceneMetrics() を 1 回呼び、cameraEngine の初期 cameraState を確定する（target/position/up/distance/fov/near/far 等）"
        - "metrics が null の場合はフォールバック規範を適用し、初期 cameraState を確定させる（例: center=[0,0,0], radius=1 を基準に距離等を決める）"
        - "createRecomputeVisibleSet(...).recomputeVisibleSet（関数）を core.recomputeVisibleSet として保持し、frameController/filters/hub から呼べるように配線する"
        - "描画ループ開始は行わず、返却した hub.start() に委譲する"
        - "入力系（PointerInput / KeyboardInput / gizmo 等）は構築せず、Host / dev harness 側の責務とする"
        - "（dev オプションが指定された場合）起動診断ログ（BOOT/MODEL/CAMERA/LAYERS/FRAME）を発行する"
        - "core 内の相互呼び出しは import ではなく bootstrap で依存注入（DI）で渡す（composition root）"
        - "validate 後に deepFreeze(document) を行い、以後 document は immutable 扱いとする（fromUrl 経由でも最終的に bootstrapViewer が実施）"
        - "（bootstrapViewerFromUrl のみ）URL から JSON をロードし、document を bootstrapViewer に渡す"
        - "bootstrapViewerFromUrl は options.strictValidate の default を true とする（未指定時は validateRefIntegrity まで実行）"
        - "bootstrapViewerFromUrl は res.ok===false の場合は throw（HTTP status を含めるのを推奨）"
        - "validate + deepFreeze は bootstrapViewer が **常に** 行う（fromUrl 側では行わない）"

        - "create*Controller は必要依存を引数で受け取れる形（DI）で構築する"
        - "初期化後に recomputeVisibleSet() を1回呼ぶ"
        - "core.structIndex（= structIndexFacade。indices内包の read-only facade）を構築して hub へ渡す"
        - "core.cameraController（= cameraController。uuid 解決などの高レベル camera API）を構築して hub へ渡す"
        - "createViewerHub に渡す core は次を含む: { uiState, frameController, selectionController, modeController, microController, visibilityController, cameraEngine, cameraController, viewerSettingsController, structIndex, recomputeVisibleSet }"
      exports:
        - name: bootstrapViewer
          signature: "(canvasOrId, threeDSS, options?) → hub"
        - name: bootstrapViewerFromUrl
          signature: "(canvasOrId, url, options?) → Promise<hub>"
        - name: ViewerBootstrapOptions
          fields:
            - name: devBootLog
              signature: "(boolean)?"
              description: "true のとき起動診断ログ（BOOT/MODEL/CAMERA/LAYERS/FRAME）を出す"
            - name: logger
              signature: "((line:string)=>void)?"
              description: "起動診断ログや dev ログの出力先。未指定なら console.log 相当でよい"
            - name: strictValidate
              signature: "(boolean)?"
              description: "true のとき validate3DSS + validateRefIntegrity を必ず実行（NGなら throw）"
            - name: validateRefIntegrity
              signature: "(boolean)?"
              description: "true のとき参照整合性チェックを実行（NGなら throw）。strictValidate=true の場合は暗黙に true と同等。"
      calls:
        # --- bootstrapViewer（validate→freeze→indices→controllers→renderer→hub）---
        - "IMPORT: runtime/core/validator.initValidator"
        - "CALL: validator = initValidator()"
        - "CALL: options = normalizeBootstrapOptions(options)  # local helper (default {})"
        - "CALL: canvas = resolveCanvas(canvasOrId)  # HTMLElement or id→canvas"
        - "CALL: if (!canvas) throw new Error('canvas not found')"
        - "CALL: document = threeDSS"
        - "CALL: validator.validate3DSS(document)"
        - "CALL: if (options.strictValidate || options.validateRefIntegrity) validator.validateRefIntegrity(document)"

        - "CALL: # normalizeBootstrapOptions の既定: { strictValidate:false, validateRefIntegrity:false, devBootLog:false }"

        - "IMPORT: runtime/core/deepFreeze.deepFreeze"
        - "CALL: deepFreeze(document)  # validate 後に必ず"

        - "IMPORT: runtime/core/uiState.createUiState"
        - "CALL: uiState = createUiState()"

        - "IMPORT: runtime/core/structIndex.buildUUIDIndex"
        - "CALL: indices = buildUUIDIndex(document)"

        - "IMPORT: runtime/core/structIndex.detectFrameRange"
        - "CALL: frameRange = detectFrameRange(document)"

        - "IMPORT: runtime/core/structIndexFacade.createStructIndexFacade"
        - "CALL: structIndex = createStructIndexFacade({ indices, document })"

        - "IMPORT: runtime/core/selectionController.createSelectionController"
        - "CALL: selectionController = createSelectionController({ uiState, indices })"

        - "IMPORT: runtime/core/microController.createMicroController"
        - "CALL: microController = createMicroController({ uiState, indices })"

        - "IMPORT: runtime/core/visibilityController.createVisibilityController"
        - "CALL: visibilityController = createVisibilityController({ uiState, document, indices })"

        - "IMPORT: runtime/core/modeController.createModeController"
        - "CALL: modeController = createModeController({ uiState, selectionController, microController, visibilityController })"

        - "IMPORT: runtime/core/viewerSettingsController.createViewerSettingsController"
        - "CALL: viewerSettingsController = createViewerSettingsController({ uiState })"

        - "IMPORT: runtime/core/cameraEngine.createCameraEngine"
        - "CALL: cameraEngine = createCameraEngine({ uiState, modeController })"

        - "IMPORT: runtime/core/cameraController.createCameraController"
        - "CALL: cameraController = createCameraController({ uiState, cameraEngine, structIndex })"

        - "IMPORT: runtime/core/recomputeVisibleSet.createRecomputeVisibleSet"
        - "CALL: { recomputeVisibleSet } = createRecomputeVisibleSet({ uiState, visibilityController, selectionController, microController, modeController })"
        - "CALL: coreRecomputeVisibleSet = recomputeVisibleSet"

        - "IMPORT: runtime/core/frameController.createFrameController"
        - "CALL: frameController = createFrameController({ uiState, frameRange, recomputeVisibleSet: coreRecomputeVisibleSet, modeController })"

        - "IMPORT: runtime/renderer/context.createRendererContext"
        - "CALL: rendererContext = createRendererContext({ canvas })"
        - "CALL: rendererContext.syncDocument(document, indices)"
        - "CALL: metrics = rendererContext.getSceneMetrics()"
        - "CALL: initialState = computeInitialCameraState(metrics)  # local helper (metrics null 対応含む)"
        - "CALL: cameraEngine.setState(initialState)"

        - "CALL: core = { uiState, frameController, selectionController, modeController, microController, visibilityController, cameraEngine, cameraController, viewerSettingsController, structIndex, recomputeVisibleSet: coreRecomputeVisibleSet }"
        - "CALL: core.recomputeVisibleSet = coreRecomputeVisibleSet"
        - "CALL: coreRecomputeVisibleSet()"

        - "IMPORT: runtime/viewerHub.createViewerHub"
        - "CALL: hub = createViewerHub({ core, renderer: rendererContext })"

        # --- bootstrapViewerFromUrl（fetch→json→bootstrapViewer）---
        - "CALL: res = await fetch(url)"
        - "CALL: if (!res.ok) throw new Error(...)"
        - "CALL: document = await res.json()"
        - "CALL: options2 = normalizeBootstrapOptionsForFromUrl(options)  # local helper (strictValidate default=true)"

        - "CALL: # normalizeBootstrapOptionsForFromUrl の既定: { strictValidate:true, validateRefIntegrity:true, devBootLog:false }"
        - "CALL: # 注記: strictValidate=true の場合、validateRefIntegrity は必ず実行される（呼び出し条件により担保）"

        - "CALL: hub = bootstrapViewer(canvasOrId, document, options2)"

      called_by:
        - "Host（Astro / HTML 側の起動コード / viewerDevHarness）"
      constraints:
        - "描画ループ（requestAnimationFrame）は持たない。hub.start に任せる"
        - "ui/* モジュールを import してはならない"
        - "3DSS が AJV で NG の場合は hub を生成せず Error を投げる"
        - "3DSS document は deepFreeze 済み immutable とみなす"
        - "推奨: Host は strict validation 済み doc を渡す。"
        - "bootstrapViewer は validate3DSS を **常に** 実行する（NGなら throw）。"
        - "validateRefIntegrity は options.strictValidate=true または options.validateRefIntegrity=true のときのみ実行する。"
        - "PointerInput / KeyboardInput は構築しない（入力系は Host / dev harness が new する）"
        - "仕様テキストに外部ツール/URL（例: chatgpt/codex 等）を混入させない（規範情報のみ）。"
        - "getSceneMetrics() が null を返しても起動不能にしない（規定の fallback で初期 cameraState を確定する）"
        - "canvasOrId が不正（見つからない / canvas でない）なら throw"
        - "options 未指定は {} 扱い（normalize で補う）"

    # =========================
    # 2.2 hub
    # =========================
    - name: runtime/viewerHub.js
      layer: hub
      responsibility:
        - "core と renderer を束ねて、UI に対して hub.core.* API を提供する"
        - "render loop（hub.start / hub.stop）を 1 箇所で管理する"
        - "UI からの呼び出しはすべて hub.core.* / hub.pickObjectAt / hub.viewerSettings.* に統一する"
        - "viewport/canvas サイズ変更を hub.resize(width,height) で受け、renderer.resize に委譲する"
      exports:
        - name: createViewerHub
          signature: "({ core, renderer }) → hub"
        - name: ViewerHub
          fields:
            - name: start
              signature: "() → void"
              description: "render loop を開始。二重 start は no-op（例外にしない）。"
            - name: stop
              signature: "() → void"
              description: "render loop を停止（RAF 停止のみ）。WebGL 資源は保持。二重 stop は no-op。"
            - name: isRunning
              signature: "() → boolean"
              description: "render loop が稼働中かを返す。"
            - name: dispose
              signature: "() → void"
              description: |
                stop + renderer.dispose（資源解放）。
                ※ onXChanged の unsubscribe は呼び出し側（UI/Host）が保持して解除する。hub は勝手に購読を作らない。
                dispose 後の hub は再利用不可。
            - name: resize
              signature: "(width:number, height:number) → void"
              description: |
                Host が canvas の表示サイズ（CSS px）を計算して渡す。
                hub は renderer.resize(width,height) に委譲する。
                その直後、未 dispose の場合は renderer.updateCamera(hub.core.camera.getState()) を **必ず** 呼ぶ。
                dispose 後は no-op。
            - name: pickObjectAt
              signature: "(ndcX:number, ndcY:number) → {uuid:string, kind:'points'|'lines'|'aux', distance:number, point:[number,number,number]} | null"
              description: |
                pick は renderer のレイキャスト結果を受け取るが、
                visibilityController.isVisible(uuid) が false の場合は必ず null として返す。
                （不可視要素は UI から選択できないことを仕様で保証する）
                dispose 後は常に null（renderer に触らない）。
            - name: viewerSettings
              signature: "ViewerSettingsAPI"
            - name: core
              signature: "ViewerCoreAPI"
      hub_shape:
        core:
          props:
            - name: uiState
              description: "uiState オブジェクトそのもの（所有権は core）。"
            - name: frame
              description: "frameController への公開ラッパ（setActive/getActive/step/next/prev/getRange/startPlayback/stopPlayback）。"
            - name: camera
              description: "cameraEngine + cameraController への公開ラッパ（rotate/pan/zoom/reset/snapToAxis/focusOn/…）。"
            - name: mode
              description: "modeController への公開ラッパ（set/get/canEnter/exit/focus）。"
            - name: micro
              description: "micro mode の enter/exit/isActive だけをまとめた薄いラッパ。"
            - name: selection
              description: "selectionController への公開ラッパ（select/clear/get）。"
            - name: filters
              description: "visibilityController の filters ラッパ（setTypeEnabled/get）。"
            - name: runtime
              description: "uiState.runtime.isFramePlaying / isCameraAuto の読み出し専用ラッパ。"
            - name: recomputeVisibleSet
              description: "visibleSet + selection/micro の後処理を再計算する正規関数（core.recomputeVisibleSet）。frameController や filters からも同じ関数が呼ばれる。"
            - name: structIndex
              description: "read-only 検索API（= structIndexFacade。indices を内包）。getCenter(uuid) などを提供。"
        viewerSettings_api:
          methods:
            - name: setWorldAxesVisible
              signature: "(visible:boolean) → void"
              calls:
                - "DI: core.viewerSettingsController.setWorldAxesVisible"
                - "CALL: core.viewerSettingsController.setWorldAxesVisible(visible)"
            - name: toggleWorldAxes
              signature: "() → void"
              calls:
               - "DI: core.viewerSettingsController.toggleWorldAxes"
               - "CALL: core.viewerSettingsController.toggleWorldAxes()"
            - name: getWorldAxesVisible
              signature: "() → boolean"
              calls:
                - "DI: core.viewerSettingsController.getWorldAxesVisible"
                - "CALL: core.viewerSettingsController.getWorldAxesVisible()"
            - name: onWorldAxesChanged
              signature: "(listener:(visible:boolean) => void) → () => void"
              calls:
                - "DI: core.viewerSettingsController.onWorldAxesChanged"
                - "CALL: core.viewerSettingsController.onWorldAxesChanged(listener)"
            - name: setMicroFXProfile
              signature: "(profile:'weak'|'normal'|'strong') → void"
              calls:
                - "DI: core.viewerSettingsController.setMicroFXProfile"
                - "CALL: core.viewerSettingsController.setMicroFXProfile(profile)"
            - name: getMicroFXProfile
              signature: "() → 'weak'|'normal'|'strong'"
              calls:
                - "DI: core.viewerSettingsController.getMicroFXProfile"
                - "CALL: core.viewerSettingsController.getMicroFXProfile()"
            - name: onMicroFXProfileChanged
              signature: "(listener:(profile:'weak'|'normal'|'strong') => void) → () => void"
              calls:
                - "DI: core.viewerSettingsController.onMicroFXProfileChanged"
                - "CALL: core.viewerSettingsController.onMicroFXProfileChanged(listener)"
          notes:
            - "viewerSettings の canonical state は core(uiState.viewerSettings)。hub は core.viewerSettingsController へ委譲するだけ。"
            - "反映は render loop 内で renderer.applyViewerSettings(uiState.viewerSettings) が行う（UI→renderer 直結は禁止を維持）。"
            - "viewerSettings.worldAxesVisible は viewer のワールド軸（HUD/オーバーレイ）の表示。filters.setAuxModuleEnabled('axis',...) は 3DSS 側 aux モジュールの可視で別物。"
      calls:
        - "DI: core.uiState  # read-only"
        - "DI: core.cameraEngine.update"

        - "DI: core.frameController.updatePlayback"

        - "DI: core.microController.refresh"
        - "DI: core.cameraEngine.getState  # render loop / resize で参照"
        - "DI: core.visibilityController.isVisible  # pick の境界強制"
        - "DI: renderer.applyFrame"
        - "DI: renderer.applyViewerSettings"
        - "DI: renderer.applyMicroFX"
        - "DI: renderer.updateCamera"
        - "DI: renderer.applySelection"
        - "DI: renderer.pickObjectAt"
        - "DI: renderer.render"
        - "DI: renderer.resize"
        - "DI: renderer.dispose"
      called_by:
        - "ui/pointerInput.js"
        - "ui/keyboardInput.js"
        - "ui/gizmo.js"
        - "ui/picker.js"
        - "ui/timeline.js（将来の独立タイムライン UI を想定）"
        - "viewerDevHarness.js（dev viewer 専用 UI）"
      constraints:
        - "frame/mode/micro/selection の判定ロジックを hub に書いてはならない。必ず core.* に委譲する"
        - "hub は引数の正規化（例: uuid vs vec の解決）すら原則 core 側へ寄せる（cameraController 等）"
        - "例外: UI 安全性の不変条件（不可視は pick できない等）の境界強制は hub 側で行ってよい"
        - "許可: ライフサイクル制御（start/stop/dispose/resize）、render loop の呼び出し順序規範、境界強制（不可視pick排除等）"
        - "禁止: mode/selection/frame の意味論（どの条件でどう遷移するか等）の判断ロジック"
        - "three.js のオブジェクトや material を直接触ってはならない"
        - "core/* や renderer/* を import してはならない（{ core, renderer } を DI で受け取って呼ぶ）"
        - "3DSS document を直接変更してはならない"
        - "hub.core.uiState は参照専用として公開する。UI/Host は uiState を直接 mutate してはならない（更新は必ず hub.core.* API 経由）。"
        - "viewerSettings は core(uiState.viewerSettings) が canonical。hub/viewerSettings API は core.viewerSettingsController に委譲し、renderer へ直接触れてはならない（反映は render loop の renderer.applyViewerSettings に一本化）。"
        - "hub は uiState.visibleSet / uiState.runtime.isFramePlaying を直接書き換えない（single-writer 遵守）"
        - "frame/selection/filter/mode の結果確定は core.* を呼ぶことで達成する"

      core_api:
        structIndex:
          - name: getCenter
            signature: "(uuid:string) → [number,number,number] | null"
            calls:
              - "DI: core.structIndex.getCenter"
              - "CALL: core.structIndex.getCenter(uuid)"
          - name: getKind
            signature: "(uuid:string) → 'points'|'lines'|'aux'|null"
            calls:
              - "DI: core.structIndex.getKind"
              - "CALL: core.structIndex.getKind(uuid)"
          - name: getItem
            signature: "(uuid:string) → object|null"
            calls:
              - "DI: core.structIndex.getItem"
              - "CALL: core.structIndex.getItem(uuid)"
        frame:
          - name: setActive
            signature: "(frame:number|null) → void"
            calls:
              - "DI: core.frameController.setActive"
              - "CALL: core.frameController.setActive(frame)"
          - name: getActive
            signature: "() → number|null"
            calls:
              - "DI: core.frameController.getActive"
              - "CALL: core.frameController.getActive()"
          - name: step
            signature: "(delta:number) → void"
            calls:
              - "DI: core.frameController.step"
              - "CALL: core.frameController.step(delta)"
          - name: next
            impl_note: "step(+1) の薄いラッパ"
            calls:
              - "CALL: step(+1)"
          - name: prev
            impl_note: "step(-1) の薄いラッパ"
            calls:
              - "CALL: step(-1)"
          - name: getRange
            signature: "() → {min:number,max:number} | null"
            calls:
              - "DI: core.frameController.getRange"
              - "CALL: core.frameController.getRange()"
          - name: startPlayback
            signature: "() → void"
            calls:
              - "DI: core.frameController.startPlayback"
              - "CALL: core.frameController.startPlayback()"
            method_notes:
              - "結果として uiState.runtime.isFramePlaying が true になる（更新は core.frameController 側）"
              - "macro へ戻すのは core.frameController.startPlayback の責務"
          - name: stopPlayback
            signature: "() → void"
            calls:
              - "DI: core.frameController.stopPlayback"
              - "CALL: core.frameController.stopPlayback()"
            method_notes:
              - "結果として uiState.runtime.isFramePlaying が false になる（更新は core.frameController 側）"

        selection:
          - name: select
            signature: "(uuid:string, kind?:'points'|'lines'|'aux') → {kind:'points'|'lines'|'aux', uuid:string}|null"
            notes:
              - "visibilityController.isVisible(uuid) が false の場合は null を返し、core.selectionController.select を呼ばない"
            calls:
              - "DI: core.visibilityController.isVisible"
              - "CALL: if (!core.visibilityController.isVisible(uuid)) return null"
              - "DI: core.selectionController.select"
              - "CALL: return core.selectionController.select(uuid, kind?)"

          - name: clear
            signature: "() → void"
            calls:
              - "DI: core.selectionController.clear"
              - "CALL: core.selectionController.clear()"
          - name: get
            signature: "() → {kind:'points'|'lines'|'aux', uuid:string}|null"
            calls:
              - "DI: core.selectionController.get"
              - "CALL: core.selectionController.get()"

        camera:
          - name: rotate
            signature: "(dTheta:number, dPhi:number) → void"
            calls:
              - "DI: core.cameraEngine.rotate"
              - "CALL: core.cameraEngine.rotate(dTheta, dPhi)"
          - name: pan
            signature: "(dx:number, dy:number) → void"
            calls:
              - "DI: core.cameraEngine.pan"
              - "CALL: core.cameraEngine.pan(dx, dy)"
          - name: zoom
            signature: "(delta:number) → void"
            calls:
              - "DI: core.cameraEngine.zoom"
              - "CALL: core.cameraEngine.zoom(delta)"
          - name: reset
            signature: "() → void"
            calls:
              - "DI: core.cameraEngine.reset"
              - "CALL: core.cameraEngine.reset()"
          - name: snapToAxis
            signature: "(axis:'x'|'y'|'z') → void"
            calls:
              - "DI: core.cameraEngine.snapToAxis"
              - "CALL: core.cameraEngine.snapToAxis(axis)"

          - name: focusOn
            signature: "(target:[number,number,number] | uuid:string, opts?) → cameraState"
            impl_note: |
              focusOn は cameraState だけを更新する（mode は変更しない）。
              uuid 解決や focus state 算出は core.cameraController が担う。
              micro 侵入は UI が mode.focus / micro.enter を別途呼ぶ。
            calls:
              - "DI: core.cameraController.focusOn"
              - "CALL: core.cameraController.focusOn(target, opts?)"
          - name: setFOV
            signature: "(value:number) → void"
            calls:
              - "DI: core.cameraEngine.setFOV"
              - "CALL: core.cameraEngine.setFOV(value)"
          - name: setViewByName
            signature: "(name:string) → void"
            calls:
              - "DI: core.cameraEngine.setViewByName"
              - "CALL: core.cameraEngine.setViewByName(name)"
          - name: setViewPreset
            signature: "(index:number, opts?) → void"
            calls:
              - "DI: core.cameraEngine.setViewPreset"
              - "CALL: core.cameraEngine.setViewPreset(index, opts?)"
          - name: getViewPresetIndex
            signature: "() → number"
            calls:
              - "DI: core.cameraEngine.getViewPresetIndex"
              - "CALL: core.cameraEngine.getViewPresetIndex()"

          - name: setState
            signature: "(partialState:object) → void"
            calls:
              - "DI: core.cameraEngine.setState"
              - "CALL: core.cameraEngine.setState(partialState)"
          - name: getState
            signature: "() → cameraState"
            calls:
              - "DI: core.cameraEngine.getState"
              - "CALL: core.cameraEngine.getState()"
          - name: startAutoOrbit
            signature: "(opts?) → void"
            calls:
              - "DI: core.cameraEngine.startAutoOrbit"
              - "CALL: core.cameraEngine.startAutoOrbit(opts?)"
          - name: updateAutoOrbitSettings
            signature: "(opts?) → void"
            calls:
              - "DI: core.cameraEngine.updateAutoOrbitSettings"
              - "CALL: core.cameraEngine.updateAutoOrbitSettings(opts?)"
          - name: stopAutoOrbit
            signature: "() → void"
            calls:
              - "DI: core.cameraEngine.stopAutoOrbit"
              - "CALL: core.cameraEngine.stopAutoOrbit()"
        mode:
          - name: set
            signature: "(mode:'macro'|'micro', uuid?:string) → 'macro'|'micro'"
            calls:
              - "DI: core.modeController.set"
              - "CALL: core.modeController.set(mode, uuid?)"
          - name: get
            signature: "() → 'macro'|'micro'"
            calls:
              - "DI: core.modeController.get"
              - "CALL: core.modeController.get()"
          - name: canEnter
            signature: "(uuid:string) → boolean"
            calls:
              - "DI: core.modeController.canEnter"
              - "CALL: core.modeController.canEnter(uuid)"
            rules:
              - "uiState.runtime を参照する"

          - name: exit
            signature: "() → 'macro'|'micro'"
            calls:
              - "DI: core.modeController.exit"
              - "CALL: core.modeController.exit()"

          - name: focus
            signature: "(uuid:string) → 'macro'|'micro'"
            calls:
              - "DI: core.modeController.focus"
              - "CALL: core.modeController.focus(uuid)"

        micro:
          - name: enter
            signature: "(uuid:string) → 'macro'|'micro'"
            calls:
              - "DI: core.modeController.set"
              - "CALL: core.modeController.set('micro', uuid)"
            method_notes:
             - "規範: canEnter=false の場合は no-op（状態変更なし）で現在の mode を返す。例外は禁止。"

          - name: exit
            signature: "() → 'macro'"
            calls:
              - "DI: core.modeController.set"
              - "CALL: core.modeController.set('macro')"
          - name: isActive
            signature: "() → boolean"
            impl_note: "uiState.mode === 'micro' を見るだけ（core 所有）"

        filters:
          - name: setTypeEnabled
            signature: "(kind:'points'|'lines'|'aux', enabled:boolean) → void"
            calls:
              - "DI: core.visibilityController.setTypeEnabled"
              - "CALL: core.visibilityController.setTypeEnabled(kind, enabled)"
              - "DI: core.recomputeVisibleSet"
              - "CALL: core.recomputeVisibleSet()"

          - name: setAuxModuleEnabled
            signature: "(module:'grid'|'axis'|'plate'|'shell'|'hud'|'extension', enabled:boolean) → void"
            calls:
              - "DI: core.visibilityController.setAuxModuleEnabled"
              - "CALL: core.visibilityController.setAuxModuleEnabled(module, enabled)"
              - "DI: core.recomputeVisibleSet"
              - "CALL: core.recomputeVisibleSet()"

          - name: get
            signature: "() → FiltersState"
            calls:
              - "DI: core.visibilityController.get"
              - "CALL: core.visibilityController.get()"

        runtime:
          - name: isFramePlaying
            signature: "() → boolean"
            impl_note: "uiState.runtime.isFramePlaying を返す。core.frame.startPlayback/stopPlayback 側でフラグを更新。"

          - name: isCameraAuto
            signature: "() → boolean"
            impl_note: "uiState.runtime.isCameraAuto を返す（AutoOrbit 中 true）。"

        # core 直下に関数として生やす（hub.core.recomputeVisibleSet()）
        recomputeVisibleSet:
          - name: recomputeVisibleSet
            signature: "() → void"
            calls:
              - "DI: core.recomputeVisibleSet"
              - "CALL: core.recomputeVisibleSet()"
    # =========================
    # 2.3 core
    # =========================
    - name: runtime/core/structIndexFacade.js
      layer: core
      responsibility:
        - "indices を内包した read-only 検索API（hub へ渡す）"
      exports:
        - name: createStructIndexFacade
          signature: "({ indices, document }) → structIndex"
      structIndex:
        methods:
          - getCenter(uuid:string): [number,number,number] | null
          - getKind(uuid:string): 'points'|'lines'|'aux'|null
          - getItem(uuid:string): object|null


    - name: runtime/core/validator.js
      layer: core
      responsibility:
        - "AJV strict validator を初期化し、3DSS と参照整合性を検証する"
      exports:
        - name: initValidator
          signature: "() → { validate3DSS, validateRefIntegrity }"
      constraints:
        - "doc を書き換えない"

    - name: runtime/core/deepFreeze.js
      layer: core
      responsibility:
        - "document を deep freeze して immutable 扱いにする"
      exports:
        - name: deepFreeze
          signature: "(obj) → obj"
      constraints:
        - "Set/Map 等 runtime state には使わない（document 専用）"

    - name: runtime/core/viewerSettingsController.js
      layer: core
      responsibility:
        - "uiState.viewerSettings の初期値を確定し、viewerSettings API を提供する（state 所有は core）"
        - "set*/toggle* で uiState.viewerSettings を更新し、登録済み listener を通知する"
        - "renderer への直接アクセスはしない（反映は hub の render loop が applyViewerSettings で行う）"
      exports:
        - name: createViewerSettingsController
          returns: viewerSettingsController
          signature: "({ uiState }) → viewerSettingsController"
      di_injected:
        - name: uiState
          source: "bootstrapViewer (createUiState result)"
      viewerSettingsController:
        methods:
          - setWorldAxesVisible(visible:boolean)
          - toggleWorldAxes()
          - getWorldAxesVisible(): boolean
          - onWorldAxesChanged(listener:(visible:boolean)=>void): () => void
          - setMicroFXProfile(profile:'weak'|'normal'|'strong')
          - getMicroFXProfile(): 'weak'|'normal'|'strong'
          - onMicroFXProfileChanged(listener:(profile:'weak'|'normal'|'strong')=>void): () => void
      defaults:
        - "worldAxesVisible: true"
        - "microFXProfile: 'normal'"
      state:
        - "uiState.viewerSettings を canonical とする"
        - "listeners は runtime-only（uiState には保持しない）"
        - "onXChanged は unsubscribe 関数を返す（同一 listener の二重登録を防ぐのは実装任意。ただし解除できることは必須）。"
      constraints:
       - "viewerSettingsController は renderer に直接アクセスしてはならない（renderer.setXxx を呼ばない）。反映は hub の render loop が renderer.applyViewerSettings(uiState.viewerSettings) で行う。"
       - "setMicroFXProfile(profile) は uiState.viewerSettings.fx.micro.profile のみ更新する（他の設定を書き換えない）。renderer.setXxx を呼ぶのも禁止（反映は hub render loop の applyViewerSettings に一本化）。"
       - "注意: microFXProfile は render 系（例: fixedLineWidth/minLineWidth 等）と無関係。混同して別フィールドを書き換えるのは禁止。"

    - name: runtime/core/cameraEngine.js
      layer: core
      calls:
        - "DI: modeController.set   # startAutoOrbit で 'macro' 強制"
      responsibility:
        - "uiState.cameraState を更新/参照し、renderer に渡すための状態を作る"
        - "startAutoOrbit/stopAutoOrbit で uiState.runtime.isCameraAuto を更新する"
        - "startAutoOrbit は modeController.set('macro') を呼び micro を必ず抜ける（micro 中の AutoOrbit を禁止する規範）"

      exports:
        - name: createCameraEngine
          returns: cameraEngine
          signature: "({ uiState, modeController }) → cameraEngine"
      di_injected:
        - name: uiState
          source: "bootstrapViewer (createUiState result)"
        - name: modeController
          source: "bootstrapViewer (createModeController result)"
      cameraEngine:
        methods:
          - rotate(dTheta:number, dPhi:number)
          - pan(dx:number, dy:number)
          - zoom(delta:number)
          - reset()
          - snapToAxis(axis:'x'|'y'|'z')
          - setState(partialState:object)
          - getState(): cameraState
          - setFOV(value:number)
          - update(dtSeconds:number)
          - setViewByName(name:string)
          - setViewPreset(index:number, opts?)
          - getViewPresetIndex(): number
          - computeFocusState(target:[number,number,number], opts?): cameraState
          - startAutoOrbit(opts?)
          - updateAutoOrbitSettings(opts?)
          - stopAutoOrbit()
      called_by:
        - "runtime/viewerHub.js（core.camera.* 経由）"
      state:
        - "uiState.cameraState を canonical とし、cameraEngine はそれを更新/参照する（内部に別コピーは持たない）"
        - "three.js の Camera インスタンスは renderer が保持し、この state を反映するだけ"

    - name: runtime/core/cameraController.js
      layer: core
      responsibility:
        - "hub から呼ばれる高レベル camera API を提供する（引数正規化・uuid 解決・focus 算出など）"
        - "cameraEngine / structIndex を束ねるが、mode は変更しない（cameraState 更新に限定）"
      exports:
        - name: createCameraController
          returns: cameraController
          signature: "({ uiState, cameraEngine, structIndex }) → cameraController"
      di_injected:
        - name: uiState
          source: "bootstrapViewer (createUiState result)"
        - name: cameraEngine
          source: "bootstrapViewer (createCameraEngine result)"
        - name: structIndex
          source: "bootstrapViewer (createStructIndexFacade result)"
      cameraController:
        methods:
          - focusOn(target:[number,number,number] | uuid:string, opts?): cameraState
      calls:
        - "DI: structIndex.getCenter"
        - "DI: cameraEngine.computeFocusState"
        - "DI: cameraEngine.setState"
      constraints:
        - "three.js を import してはならない"
        - "renderer に直接アクセスしてはならない"
      called_by:
        - "runtime/viewerHub.js（core.camera.focusOn 経由）"

    - name: runtime/core/frameController.js
      layer: core
      responsibility:
        - "active frame を管理する"
        - "frameRange を決定し、uiState.frame に保持する"
        - "frameRange は structIndex.detectFrameRange() を使い、v1.1.0 の frames:number|number[] を解釈して算出する"
        - "初期 activeFrame は次で統一する:"
        - "  - frameRange === null のとき: activeFrame = null（フレーム絞り込み無し）"
        - "  - frameRange !== null のとき: activeFrame = frameRange.min（最初のフレームから開始）"
        - "startPlayback/stopPlayback で uiState.runtime.isFramePlaying を更新する"
        - "startPlayback は modeController.set('macro') を必ず呼ぶ"
      constraints:
        - "uiState.runtime.isFramePlaying を直接代入してよいのは frameController のみ（single-writer）"
      exports:
        - name: createFrameController
          returns: frameController
          signature: "({ uiState, frameRange, recomputeVisibleSet, modeController }) → frameController"
      di_injected:
        - name: uiState
          source: "bootstrapViewer (createUiState result)"
        - name: frameRange
          source: "bootstrapViewer (structIndex.detectFrameRange result)"
        - name: recomputeVisibleSet
          source: "bootstrapViewer (core.recomputeVisibleSet)"
        - name: modeController
          source: "bootstrapViewer (createModeController result)"

      frameController:
        methods:
          - setActive(frame:number|null)
          - getActive(): number|null
          - step(delta:number)
          - getRange(): {min:number,max:number} | null
          - startPlayback(): void
          - stopPlayback(): void


          - updatePlayback(dtSeconds:number): void

      playback_policy:
        - "startPlayback(): uiState.runtime.isFramePlaying = true; accumulator をリセット"
        - "stopPlayback(): uiState.runtime.isFramePlaying = false; accumulator をリセット"
        - "updatePlayback(dtSeconds): isFramePlaying===false なら no-op。dt を積算して必要ステップだけ frame を進め、上限到達で stopPlayback()"
        - "frame を進める経路は setActive/内部 setActive を通し、結果として recomputeVisibleSet の正規ルートが維持される"
 
      internal_state:

        - "playbackAccumulatorSeconds: number  # frameController 内部にのみ保持（uiState には保持しない）"
        - "playbackStepSeconds: number  # 既定 1/30（実装判断で可。仕様は『一定間隔で step する』を要求）"

      method_notes:
        - "step(delta):"
        - "  - frameRange === null のとき no-op"
        - "  - activeFrame === null のとき:"
        - "      delta > 0 → setActive(frameRange.min)"
        - "      delta < 0 → setActive(frameRange.max)"
        - "      delta = 0 → no-op"
        - "  activeFrame !== null のときは **必ず clamp**（min/max で打ち止め）"
        - "setActive/step は activeFrame 更新後に recomputeVisibleSet() を必ず呼ぶ（frame変更後の唯一の正規ルート）"
      calls:
        - "DI: recomputeVisibleSet"
        - "CALL: recomputeVisibleSet()"
        - "DI: modeController.set"

        - "CALL: # updatePlayback は setActive/step を内部利用して進行させる（recomputeVisibleSet を必ず通す）"
 
      called_by:
        - "runtime/viewerHub.js（core.frame.* 経由）"
      state:
        - "activeFrame と frameRange を uiState.frame に保持する（current:number|null, range:{min,max}|null）。"

    - name: runtime/core/selectionController.js
      layer: core
      responsibility:
        - "現在の選択要素（kind, uuid）および hover 状態を管理する"
      exports:
        - name: createSelectionController
          returns: selectionController
          signature: "({ uiState, indices }) → selectionController"
      di_injected:
        - name: uiState
          source: "bootstrapViewer (createUiState result)"
        - name: indices
          source: "bootstrapViewer (structIndex.buildUUIDIndex result)"
      selectionController:
        methods:
          - select(uuid:string, kind?:'points'|'lines'|'aux'): {kind:'points'|'lines'|'aux', uuid:string} | null
          - clear()
          - get(): {kind:'points'|'lines'|'aux', uuid:string} | null
          - setHover(payload:{uuid:string|null,kind:'points'|'lines'|'aux'|null})
          - getHover(): {kind:'points'|'lines'|'aux'|null, uuid:string|null}
        method_notes:
          - "kind 未指定の場合は indices から推定する。uuid 不明、または kind 不一致の場合は null を返す。"
        calls: []
        called_by:
          - "runtime/viewerHub.js（core.selection.*）"
          - "core/modeController.js"
        state:
          - "uiState.selection を更新する（SelectionState|null）。null は未選択。"
          - "uiState.hover を更新する（HoverState|null）。null は hover 無し（hover 機能採用時）。"

    - name: runtime/core/modeController.js
      layer: core
      responsibility:
        - "mode（macro/micro）と micro 侵入条件の優先ルールを管理する"
      exports:
        - name: createModeController
          returns: modeController
          signature: "({ uiState, selectionController, microController, visibilityController }) → modeController"
      di_injected:
        - name: uiState
          source: "bootstrapViewer (createUiState result)"
        - name: selectionController
          source: "bootstrapViewer (createSelectionController result)"
        - name: microController
          source: "bootstrapViewer (createMicroController result)"
        - name: visibilityController
          source: "bootstrapViewer (createVisibilityController result)"
      modeController:
        methods:
          - set(mode:'macro'|'micro', uuid?:string): 'macro'|'micro'
          - get(): 'macro'|'micro'
          - canEnter(uuid:string): boolean
          - exit(): 'macro'|'micro'
          - focus(uuid:string): 'macro'|'micro'
        calls:
          - "DI: selectionController.select"
          - "DI: selectionController.get"
          - "DI: microController.refresh"
          # activeFrame は uiState.frame.current を参照する（frameController 依存を持たない）
          - "DI: visibilityController.isVisible"
        called_by:
          - "runtime/viewerHub.js（core.mode.*, core.micro.*）"
        rules:
          - "uiState.runtime.isFramePlaying === true の間は canEnter(uuid) を必ず false にする（micro 侵入禁止）"
          - "再生開始時の mode='macro' 強制は core.frameController.startPlayback が担保する"
          - "micro は visibleSet 内の要素にだけ適用される"
          - "canEnter は isFramePlaying / isCameraAuto / visibilityController.isVisible(uuid) をチェックする（frame 条件は visibleSet に反映済み）"
          - "isFramePlaying / isCameraAuto は core 所有の uiState.runtime を参照して判定する"
          - "set('micro', uuid) は内部で必ず canEnter(uuid) を評価し、満たさない場合は **no-op**（状態変更なし）で現在の mode を返す（例外禁止）"
          - "mode が 'macro' に遷移した場合は uiState.microState を必ず null にする（microFX off を保証）"
          - "set('micro') で uuid が未指定の場合は selection.uuid を用いる。selection が null の場合は no-op で現状 mode を返す。"
        state:
          - "uiState.mode を更新する"
          - "uiState.microState は microController.refresh() により更新する（mode==='micro' の間の正規ルート）"

    - name: runtime/core/microController.js
      layer: core
      responsibility:
        - "selection + cameraState + indices から microState（= MicroFXPayload）を算出する"
      exports:
        - name: createMicroController
          returns: microController
          signature: "({ uiState, indices }) → microController"
      di_injected:
        - name: uiState
          source: "bootstrapViewer (createUiState result)"
        - name: indices
          source: "bootstrapViewer (structIndex.buildUUIDIndex result)"
      microController:
        methods:
          - compute(selection, cameraState): MicroFXPayload | null   # optional: pure helper として残すなら残す
          - refresh(): MicroFXPayload | null
        notes:
          - "refresh() は uiState.microState を更新する（mode!=='micro' のときは uiState.microState=null を保証）。戻り値は更新後の値（MicroFXPayload|null）。"
          - "規範: 呼び出し側は原則として代入しない（refresh の副作用を正とする）。"
        calls: []
        called_by:
          - "core/modeController"
          - "core.recomputeVisibleSet()（bootstrapViewer が core にぶら下げる補助メソッド）"
          - "runtime/viewerHub.js（render loop 内で refresh）"
        constraints:
          - "three.js を import してはならない"
          - "renderer に直接アクセスしてはならない"
        microState_shape:
          - "MicroFXPayload 型（3DSD-viewer.md 7.11 節）と同型のオブジェクト、または null を返す"
          - "renderer は unknown なフィールドは無視して良い"

    - name: runtime/core/visibilityController.js
      layer: core
      responsibility:
        - "appearance.visible / frames / filters を合成し、visibleSet を計算する"
        - "v1.1.0: appearance.visible は default を持たないため、未指定(undefined)は true 扱いとする（false のときのみ非表示）"
        - "v1.1.0: appearance.frames は number | number[] を許容し、activeFrame と照合して可視判定する"
      rules:
        - "visible: undefined ⇒ true / false ⇒ hidden"
        - "frames: undefined ⇒ 全フレームで可視"
        - "activeFrame === null のとき: frames は判定に使わず（visible と filters のみ）可視判定する"
        - "activeFrame !== null のとき: frames が number なら一致時のみ可視、number[] なら含まれるとき可視"
      exports:
        - name: createVisibilityController
          returns: visibilityController
          signature: "({ uiState, document, indices }) → visibilityController"
      di_injected:
        - name: uiState
          source: "bootstrapViewer (createUiState result)"
        - name: document
          source: "bootstrapViewer (validated + deepFreeze 済み 3DSS)"
        - name: indices
          source: "bootstrapViewer (structIndex.buildUUIDIndex result)"

      visibilityController:
        methods:
          - recompute(): VisibleSet
          - isVisible(uuid:string): boolean
          - get(): FiltersState
          - setTypeEnabled(kind:'points'|'lines'|'aux', enabled:boolean)
          - setAuxModuleEnabled(module:'grid'|'axis'|'plate'|'shell'|'hud'|'extension', enabled:boolean)
      method_notes:
        - "setTypeEnabled/setAuxModuleEnabled は filters の状態更新のみ行う"
        - "visibleSet 再計算と selection/micro 後処理は caller が core.recomputeVisibleSet() を呼んで保証する（循環依存回避）"
        - "isVisible(uuid) は uiState.visibleSet の points/lines/aux の membership を見る（visibleSet が null の場合は false）"
      calls: []
      called_by:
        - "runtime/viewerHub.js（core.filters.*）"
        - "core/recomputeVisibleSet"
        - "core/modeController"
      state:
        - "uiState.visibleSet は core.recomputeVisibleSet が更新し、visibilityController は参照のみ"
        - "uiState.filters を {points,lines,aux,auxModules?:Record<string,boolean>} として保持する"

    - name: runtime/core/uiState.js
      layer: core
      responsibility:
        - "viewer の UI 状態を一元管理する（document とは分離）"
      exports:
        - name: createUiState
          returns: uiState
          signature: "() → uiState"
      fields:
        - "frame: {current:number|null, range:{min:number,max:number}|null}"
        - "runtime: {isFramePlaying:boolean, isCameraAuto:boolean}"
        - "filters: {points:boolean, lines:boolean, aux:boolean, auxModules:Record<string,boolean>}"
        - "visibleSet: VisibleSet | null"
        - "mode: 'macro'|'micro'"
        - "selection: SelectionState | null"
        - "hover: HoverState | null"
        - "microState: MicroState | null"
        - "cameraState: CameraState"
        - "viewerSettings: {worldAxesVisible:boolean, infoDisplay:'select'|'hover'|'off', render:{minLineWidth:number,fixedLineWidth:number,shadow:{enabled:boolean,intensityScale:number}}, camera:{fov:number,near:number,far:number,keyboardStepYaw:number,keyboardStepPitch:number,panStep:number,zoomStep:number}, fx:{micro:{enabled:boolean,profile:'weak'|'normal'|'strong',radius:{inner_ratio:number,outer_ratio:number},fade:{min_opacity:number,hop_boost:number,far_factor:number}}, meso:boolean, modeTransitions:boolean, depthOfField:boolean, glow:boolean, flow:boolean}}"
      types:
          VisibleSet:
            - "frame:number|null"
            - "points:Set<string>"
            - "lines:Set<string>"
            - "aux:Set<string>"
          SelectionState:
            - "uuid:string"
            - "kind:'points'|'lines'|'aux'"
          HoverState:
            - "uuid:string"
            - "kind:'points'|'lines'|'aux'"
      defaults:
        - "filters: { points:true, lines:true, aux:true, auxModules:{grid:true, axis:true, plate:true, shell:true, hud:true, extension:true} }"
        - "frame: { current:null, range:null }"
        - "visibleSet: null  # 初期化後に core.recomputeVisibleSet() で確定"
        - "mode: 'macro'"
        - "selection: null"
        - "hover: null"
        - "runtime: {isFramePlaying:false, isCameraAuto:false}"
        - "viewerSettings: {worldAxesVisible:true, infoDisplay:'select', render:{minLineWidth:1.0,fixedLineWidth:2.0,shadow:{enabled:false,intensityScale:1.0}}, camera:{fov:50,near:0.1,far:1000,keyboardStepYaw:0.1,keyboardStepPitch:0.1,panStep:0.25,zoomStep:0.2}, fx:{micro:{enabled:true,profile:'normal',radius:{inner_ratio:0.1,outer_ratio:0.4},fade:{min_opacity:0.05,hop_boost:0.6,far_factor:0.2}}, meso:false, modeTransitions:false, depthOfField:false, glow:false, flow:false}}"


    - name: runtime/core/structIndex.js
      layer: core
      responsibility:
        - "3DSS document から uuid インデックスと frameRange を構築する"
      exports:
        - name: buildUUIDIndex
          signature: "(document) → { uuidToKind:Map<string,kind>, ... }"
        - name: getCenter
          signature: "(indices, uuid:string) → [number,number,number] | null"
          description: "pointはその座標、lineは中点、auxは代表点（実装定義）"
        - name: detectFrameRange
          signature: "(document) → {min:number,max:number} | null"
          description: |
            v1.1.0: appearance.frames は number | number[]。
            points/lines/aux 全要素の frames を走査して min/max を返す。
            frames が1件も無い場合は null。
      called_by:
        - "bootstrapViewer"

    - name: runtime/core/recomputeVisibleSet.js
      layer: core
      responsibility:
        - "visibilityController.recompute() を呼び uiState.visibleSet を更新"
        - "selection が不可視になった場合の不変条件を保証:"
        - "  - selectionController.clear() を呼ぶ（推奨：保持しない）"
        - "selection が不可視になった場合、modeController.set('macro') で micro を確実に抜ける"
        - "selection が可視で mode が micro の場合は microController.refresh() で microState を再計算"
      exports:
        - name: createRecomputeVisibleSet
          signature: "({ uiState, visibilityController, selectionController, microController, modeController }) → { recomputeVisibleSet }"
      di_injected:
        - name: uiState
          source: "bootstrapViewer (createUiState result)"
        - name: visibilityController
          source: "bootstrapViewer (createVisibilityController result)"
        - name: selectionController
          source: "bootstrapViewer (createSelectionController result)"
        - name: microController
          source: "bootstrapViewer (createMicroController result)"
        - name: modeController
          source: "bootstrapViewer (createModeController result)"
      calls:
        - "DI: visibilityController.recompute"
        - "CALL: canonicalVisibleSet = visibilityController.recompute()"
        - "CALL: uiState.visibleSet = canonicalVisibleSet  # single-writer"
        - "DI: selectionController.get"
        - "CALL: sel = selectionController.get()"
        - "DI: visibilityController.isVisible"
        - "CALL: if (sel && !visibilityController.isVisible(sel.uuid)) { selectionController.clear(); modeController.set('macro'); return; }"
        - "DI: selectionController.clear  # selection が不可視なら"
        - "DI: modeController.set         # selection 不可視なら 'macro' 強制"
        - "DI: microController.refresh    # selection 可視かつ mode==='micro' のとき"
        - "CALL: if (uiState.mode === 'micro') microController.refresh()"
      notes:
        - "recomputeVisibleSet() は bootstrapViewer で生成され、他 core モジュールへ DI で配布される（import 参照しない）。"
      constraints:
        - "uiState.microState へ直接代入してよいのは microController.refresh() のみ（single-writer）。"

    # =========================
    # 2.4 renderer
    # =========================
    - name: runtime/renderer/context.js
      layer: renderer
      responsibility:
        - "three.js renderer / scene / camera を初期化し、Core から渡された状態を描画する"
      exports:
        - name: createRendererContext
          returns: rendererContext
          signature: "({ canvas }) → rendererContext"
        - name: rendererContext
          methods:
            - syncDocument(document, indices)
            - getSceneMetrics(): {center:[number,number,number], radius:number} | null
            - applyFrame(visibleSet:VisibleSet|null)
            - updateCamera(cameraState)
            - applyViewerSettings(viewerSettings)
            - applyMicroFX(microState)
            - applySelection(selectionState:SelectionState|null)
            - pickObjectAt(ndcX:number, ndcY:number): {uuid:string, kind:'points'|'lines'|'aux', distance:number, point:[number,number,number]} | null
            - render()
            - resize(width:number, height:number)
            - dispose()
      internal_state:
        - "renderer: THREE.WebGLRenderer"
        - "scene: THREE.Scene"
        - "camera: THREE.PerspectiveCamera"
        - "ambientLight: THREE.AmbientLight"
        - "dirLight: THREE.DirectionalLight"
        - "pointObjects: Map<string,THREE.Object3D>  # key=uuid"
        - "lineObjects: Map<string,THREE.Object3D>  # key=uuid"
        - "auxObjects: Map<string,THREE.Object3D>   # key=uuid"
        - "baseStyle: Map<string,{color:THREE.Color,opacity:number, renderOrder:number}>  # color は clone を保存"
        - "raycaster: THREE.Raycaster"
        - "viewerSettingsCache: {worldAxesVisible:boolean,microProfile:'weak'|'normal'|'strong'}"
        - "pickTargets: THREE.Object3D[]  # uuid を持つ対象だけ入れる"
        - "lastMicroState: MicroFXPayload | null"
      lifecycle:
        init:
          - "new THREE.WebGLRenderer({ canvas, antialias:true })"
          - "renderer.setPixelRatio(window.devicePixelRatio || 1)"
          - "renderer.setSize(canvas.clientWidth, canvas.clientHeight, false)"
          - "scene = new THREE.Scene()"
          - "camera = new THREE.PerspectiveCamera(fov, aspect, near, far) # 初期値は暫定。最初の updateCamera(cameraState) で確定値に上書きされる"
          - "scene に AmbientLight / DirectionalLight を追加"
        syncDocument:
          - "前回の point/line/aux オブジェクトを scene から remove"
          - "各 object の geometry/material/texture を dispose（可能な範囲で）"
          - "Map を clear"
          - "3DSS document の points/lines/aux から三次元オブジェクトを生成（未定義は空配列扱い）"
          - "各オブジェクトに userData.uuid を付与し、対応する Map に登録"
          - "pick のため、各オブジェクトに userData.kind = 'points'|'lines'|'aux' を付与する"
          - "baseStyle Map に元の color(clone) / opacity / renderOrder を保存"
          - "pickTargets を再構築（uuid を持つ object だけ）"
          - "lastMicroState = null"
        dispose:
          - "scene から全 object を remove"
          - "geometry/material/texture を可能な範囲で dispose"
          - "WebGLRenderer.dispose() / forceContextLoss は実装判断（可能なら dev 時のみ）"
          - "Map / 配列 / cache を clear"
          - "lastMicroState = null"
        applyFrame:
          - "visibleSet（VisibleSet|null）を受け取り、points/lines/aux の membership に従って各オブジェクトの obj.visible を更新する"
          - "visibleSet===null の場合は安全側で全非表示（または no-op）にしてよいが、推奨は全非表示（初回 recompute 前のチラつき防止）"
        applyViewerSettings:
          - "viewerSettings.worldAxesVisible に従い、world axes 表示（HUD/scene どちらでも可）を on/off"
          - "viewerSettings.render / viewerSettings.fx のうち、renderer が必要とする範囲を内部キャッシュに保持し、applyMicroFX 等の強度/閾値に反映してよい（applyMicroFX の signature は変えない）"
          - "micro profile は viewerSettings.fx.micro.profile を参照する"
        applyMicroFX:
          - "microState が null の場合: baseStyle に従って color/opacity/renderOrder をフルリセット"
          - "microState が MicroFXPayload の場合: **必ず baseStyle から開始して**（= 前段 selection 等の残りを消してから） focus/connection/distance 等に応じて opacity/color を変更する"
          - "lastMicroState = microState"
        updateCamera:
          - "camera.position / camera.up を cameraState から設定"
          - "target ベクトルに対して camera.lookAt(target)"
          - "near/far/fov が変わった場合は camera.near/far/fov 更新 ＋ updateProjectionMatrix()"
          - "規範: updateCamera は camera.aspect を更新してはならない（aspect は resize の責務）。"
        applySelection:
          - "selectionState（SelectionState|null）を受け取り、**macro 用**の軽い selection ハイライトを適用してよい（null なら selection をクリアする）"
          - "優先順位: **microFX > selection（macro） > baseStyle**"
          - "防御的規範: lastMicroState != null の間は no-op（microFX 優先）。※ mode 判定や uiState 参照は renderer で行わない（呼び出し条件は hub が担保）"
        pickObjectAt:
          - "raycaster.setFromCamera({x:ndcX,y:ndcY}, camera)"
          - "raycaster.intersectObjects(pickTargets, true) の最前面ヒットから、parent を辿って userData.uuid を持つ最初のノードを採用して返す（子meshヒット対策）"
        render:
          - "renderer.render(scene, camera)"
        resize:
          - "renderer.setSize(width, height, false)"
          - "camera.aspect = width/height; camera.updateProjectionMatrix()"
          - "規範: aspect 更新は resize のみ。updateCamera で aspect を触らない。"
      calls: []
      called_by:
        - "bootstrapViewer（初期化）"
        - "runtime/viewerHub.js"
      constraints:
        - "3DSS document を書き換えてはならない"
        - "visibleSet / microState / selectionState / cameraState の canonical 所有者は core であり、renderer は各フレームで受け取って反映するだけ"
        - "mode や selection の判定ロジックを実装してはならない"
        - "UI layer は renderer を直接 import してはならない（pickObjectAt も必ず viewerHub.pickObjectAt 経由）"
        - "外部公開 API としての highlight は applySelection/applyMicroFX のみ（setHighlight/clearAllHighlights を export しない）"

    # =========================
    # 2.5 UI Bridge
    # =========================
    # Pointer/Keyboard 入力も含めて、
    # UI 層は「DOM 入力 / UI → hub.core.* / hub.pickObjectAt / hub.viewerSettings.*」のみを担当する。

    - name: ui/gizmo.js
      layer: ui
      responsibility:
        - "画面右下の HUD 軸ギズモを描画し、クリックで camera snap/home を呼ぶ"
      exports:
        - name: attachGizmo
          signature: "(wrapperElement:HTMLElement, hub) → void"
      calls:
        - "DI: hub.core.camera.snapToAxis"
        - "CALL: hub.core.camera.snapToAxis(axis)"
        - "DI: hub.core.camera.reset"
        - "CALL: hub.core.camera.reset()"
      called_by:
        - "viewerDevHarness.js（dev）"
        - "Host: viewerHost.js（prod host。gizmo 採用時のみ）"
      constraints:
        - "three.js 本体の scene には入らず、HUD overlay として DOM で描画する"

    - name: ui/picker.js
      layer: ui
      responsibility:
        - "canvas 上のクリック座標から uuid を取得し、selection を更新する"
      exports:
        - name: createPicker
          returns: picker
        - name: picker
          methods:
            - attach(domElement)
            - detach()
      calls:
        - "DI: hub.pickObjectAt"
        - "CALL: hit = hub.pickObjectAt(ndcX, ndcY)"
        - "DI: hub.core.selection.select"
        - "CALL: hub.core.selection.select(hit.uuid, hit.kind)"
      called_by:
        - "viewerDevHarness.js（dev）"
        - "Host: viewerHost.js（prod host の UI 初期化エントリ。名称は実装に合わせる）"

    - name: ui/timeline.js
      layer: ui
      responsibility:
        - "frame scrub / play/pause UI と core.frame.* を接続する（dev harness に一体化してもよい）"
      exports:
        - name: createTimeline
          returns: timeline
        - name: timeline
          methods:
            - attach(domRoot:HTMLElement)
            - detach()
      calls:
        - "DI: hub.core.frame.setActive"
        - "CALL: hub.core.frame.setActive(frame)"
        - "DI: hub.core.frame.next"
        - "CALL: hub.core.frame.next()"
        - "DI: hub.core.frame.prev"
        - "CALL: hub.core.frame.prev()"
        - "DI: hub.core.frame.getRange"
        - "CALL: hub.core.frame.getRange()"
        - "DI: hub.core.frame.startPlayback"
        - "CALL: hub.core.frame.startPlayback()"
        - "DI: hub.core.frame.stopPlayback"
        - "CALL: hub.core.frame.stopPlayback()"
      called_by:
        - "viewerDevHarness.js（dev）"
        - "Host: viewerHost.js（prod host。timeline 採用時のみ）"

    - name: ui/pointerInput.js
      layer: ui
      responsibility:
        - "canvas 上の Pointer（Mouse/Wheel）入力を hub.core.camera / hub.pickObjectAt にマッピングする UI 入力レイヤ"
      exports:
        - name: PointerInput
          type: class
          constructor: "(canvas:HTMLCanvasElement, hub) → PointerInput"
          methods:
            - dispose()
      calls:
        - "DI: hub.core.camera.rotate"
        - "CALL: hub.core.camera.rotate(dTheta, dPhi)"
        - "DI: hub.core.camera.pan"
        - "CALL: hub.core.camera.pan(dx, dy)"
        - "DI: hub.core.camera.zoom"
        - "CALL: hub.core.camera.zoom(delta)"
        - "DI: hub.pickObjectAt"
        - "CALL: hit = hub.pickObjectAt(ndcX, ndcY)"
        - "DI: hub.core.selection.select"
        - "CALL: hub.core.selection.select(hit.uuid, hit.kind)"
        - "DI: hub.core.mode.set"
        - "CALL: hub.core.mode.set(mode, uuid?)"
      called_by:
        - "viewerDevHarness.js（dev）"
        - "Host: viewerHost.js（prod host）"
      constraints:
        - "runtime/core からは PointerInput を import してはならない（UI 専用）"
        - "CameraEngine に直接触らず、原則として hub.core.camera.* 経由で操作する（移行中は cameraEngine 直叩きの互換コードが残る場合がある）"

    - name: ui/keyboardInput.js
      layer: ui
      responsibility:
        - "window の keydown を 1 箇所に集約し、hub.core.camera / hub.core.frame / hub.core.mode / hub.core.selection / hub.viewerSettings だけを叩く"
      exports:
        - name: KeyboardInput
          type: class
          constructor: "(target:Window, hub) → KeyboardInput"
          methods:
            - dispose()
      calls:
        - "DI: hub.viewerSettings.toggleWorldAxes"
        - "CALL: hub.viewerSettings.toggleWorldAxes()"
        - "DI: hub.core.frame.step"
        - "CALL: hub.core.frame.step(delta)"
        - "DI: hub.core.frame.getRange（将来の UI 用に予約）"
        - "CALL: hub.core.frame.getRange()"
        - "DI: hub.core.mode.set"
        - "CALL: hub.core.mode.set(mode, uuid?)"
        - "DI: hub.core.mode.get"
        - "CALL: hub.core.mode.get()"
        - "DI: hub.core.selection.get"
        - "CALL: hub.core.selection.get()"
        - "DI: hub.core.camera.rotate"
        - "CALL: hub.core.camera.rotate(dTheta, dPhi)"
        - "DI: hub.core.camera.zoom"
        - "CALL: hub.core.camera.zoom(delta)"
        - "DI: hub.core.camera.reset"
        - "CALL: hub.core.camera.reset()"
        - "DI: hub.core.camera.setViewPreset"
        - "CALL: hub.core.camera.setViewPreset(index, opts?)"
        - "DI: hub.core.camera.getViewPresetIndex"
        - "CALL: hub.core.camera.getViewPresetIndex()"
      called_by:
        - "viewerDevHarness.js（dev）"
        - "Host: viewerHost.js（prod host。keyboard 採用時のみ）"
      keymap:
        - "C / c: viewerSettings.toggleWorldAxes()"
        - "Backslash / IntlYen / IntlRo / '\\' / '¥': view preset index を ±1 巡回（Shift で逆方向）"
        - "PageUp:   frame.step(+1)"
        - "PageDown: frame.step(-1)"
        - "Esc:      mode.set('macro')"
        - "Home:     camera.reset()"
        - "+ / NumpadAdd:      camera.zoom(-0.1)"
        - "- / NumpadSubtract: camera.zoom(+0.1)"
        - "ArrowLeft/Right/Up/Down: camera.rotate(±Δθ,±Δφ)（Shift で倍速）"
      constraints:
        - "INPUT / TEXTAREA にフォーカスがある場合はキーを無視する"
        - "runtime/core からは KeyboardInput を import してはならない（UI 専用）"

    # =========================
    # 2.6 Host / DevHarness
    # =========================

    - name: viewerDevHarness.js
      layer: ui
      responsibility:
        - "bootstrapViewerFromUrl で hub を生成"
        - "host_ui_attach.profiles.devHarness_full に従って UI を attach"
        - "hub.start() を呼ぶ"
        - "ResizeObserver 等で hub.resize(width,height) を呼ぶ"
      calls:
        - "IMPORT: runtime/bootstrapViewer.bootstrapViewerFromUrl"
        - "CALL: hub = await bootstrapViewerFromUrl(canvasOrId, url, options)"
        - "IMPORT: ui/pointerInput.PointerInput"
        - "CALL: pointer = new PointerInput(canvas, hub)"
        - "IMPORT: ui/keyboardInput.KeyboardInput"
        - "CALL: keyboard = new KeyboardInput(window, hub)"
        - "IMPORT: ui/gizmo.attachGizmo"
        - "CALL: attachGizmo(wrapperEl, hub)"
        - "IMPORT: ui/picker.createPicker"
        - "CALL: picker = createPicker(hub); picker.attach(canvas)"
        - "IMPORT: ui/timeline.createTimeline"
        - "CALL: timeline = createTimeline(hub); timeline.attach(timelineRoot)"
        - "CALL: hub.start()"

    - name: viewerHost.js
      layer: ui
      responsibility:
        - "本番 Host の UI 初期化エントリ"
        - "選択した host_ui_attach.profile に従って attach セットを構築"
      calls:
        - "IMPORT: runtime/bootstrapViewer.bootstrapViewer / bootstrapViewerFromUrl"
        - "CALL: hub = ..."
        - "CALL: if (profile==='prod_minimal') { new PointerInput(canvas, hub); attachGizmo(wrapperEl, hub); }"
        - "CALL: if (profile==='prod_full') { new PointerInput(canvas, hub); new KeyboardInput(window, hub); attachGizmo(wrapperEl, hub); createPicker(hub).attach(canvas); createTimeline(hub).attach(timelineRoot); }"
 
        - "CALL: hub.start()"



  # =========================================================
  # 3. Runtime フロー
  # =========================================================

  # =========================================================
  # 3.1 Host UI attach プロファイル（dev/prod）
  # =========================================================

  host_ui_attach:

    # Host は「hub を生成する」＋「必要 UI を attach する」だけを責務とする
    principles:
      - "UI attach は Host/devHarness の責務。runtime(core/renderer/hub) は UI を import しない。"
      - "採用 UI は profile で宣言し、startup フローは profile に従う。"
      - "profile に含めない UI は attach しない（機能差を明示する）。"

    profiles:

      devHarness_full:
        description: "開発用フル装備（検証/デバッグ優先）"
        attach:
          - "ui/pointerInput.js: PointerInput(canvas, hub)"
          - "ui/keyboardInput.js: KeyboardInput(window, hub)"
          - "ui/gizmo.js: attachGizmo(wrapperEl, hub)"
          - "ui/picker.js: createPicker(hub).attach(canvas)"
          - "ui/timeline.js: createTimeline(hub).attach(timelineRoot)"
        notes:
          - "timeline は frameRange が null の場合 UI を disable 表示にしてよい（attach 自体は可）。"

      prod_minimal:
        description: "本番最小（操作と閲覧のみ）"
        attach:
          - "ui/pointerInput.js: PointerInput(canvas, hub)"
          - "ui/gizmo.js: attachGizmo(wrapperEl, hub)"
        notes:
          - "picker は採用しない（クリック選択なし運用）。"
          - "keyboard は採用しない（ショートカット無し運用）。"
          - "timeline は採用しない（frame UI なし運用）。"

      prod_full:
        description: "本番フル（ユーザー操作を全部提供）"
        attach:
          - "ui/pointerInput.js: PointerInput(canvas, hub)"
          - "ui/keyboardInput.js: KeyboardInput(window, hub)"
          - "ui/gizmo.js: attachGizmo(wrapperEl, hub)"
          - "ui/picker.js: createPicker(hub).attach(canvas)"
          - "ui/timeline.js: createTimeline(hub).attach(timelineRoot)"
        notes:
          - "入力衝突（drag中クリック等）の優先順位は UI 層で解決する（hub/core にロジックを持ち込まない）。"



  runtime_flow:
    startup:
      - "Host が bootstrapViewerFromUrl(canvas, url, options) or bootstrapViewer(canvas, doc, options) を呼ぶ"
      - "推奨: bootstrapViewer(canvas, doc) を使う場合、Host は事前に strict validate 済み doc を渡す（bootstrapViewer 側で validate3DSS は常に実行される）"
      - "bootstrapViewerFromUrl が JSON load → bootstrapViewer に渡す（validate/deepFreeze は bootstrapViewer が行う）"
      - "bootstrapViewer が uiState / indices / rendererContext / viewerHub を生成する（順: validate→deepFreeze→indices/frameRange→structIndexFacade→controllers→renderer.syncDocument→getSceneMetrics→cameraEngine.setState→core.recomputeVisibleSet→createViewerHub）"
      - "options.devBootLog === true のとき、起動診断ログ（BOOT/MODEL/CAMERA/LAYERS/FRAME）を 1 回ずつ送る（logger 未指定なら console.log 相当にフォールバック可）"
      - "Host / dev harness が PointerInput(canvas, hub) / KeyboardInput(window, hub) を構築し、入力イベントを hub.core.* / hub.pickObjectAt / hub.viewerSettings に集約する"
      - "Host / dev harness が gizmo / timeline / HUD 等の ui/* を初期化し、hub.core.* / hub.pickObjectAt にイベントを接続する"
      - "Host / dev harness が hub.start() を呼び、render loop を開始する（複数回呼んでも no-op）。"
      - "終了時は hub.stop()（一時停止）または hub.dispose()（完全破棄）を呼ぶ。"

    frame_update:
      - "UI（slider / ボタン / KeyboardInput の PgUp/PgDn）が hub.core.frame.setActive / step を呼ぶ"
      - "core.frameController が activeFrame を更新する（null を許容）"
      - "core.frameController は更新後に core.recomputeVisibleSet() を呼び、visibleSet 再計算と selection/micro の後処理（clear/exit/microState null/refresh）を保証する"
      - "次フレームの hub tick で renderer.applyFrame(uiState.visibleSet) および renderer.applyMicroFX(uiState.microState) が呼ばれる"
      - "playback 中は hub tick が core.frameController.updatePlayback(dtSeconds) を呼び、setActive を通じて frame を進行させる"

    selection_update:
      - "PointerInput / ui picker が canvas 座標から NDC 座標を計算し、hub.pickObjectAt(ndcX, ndcY) を呼ぶ"
      - "viewerHub が renderer.pickObjectAt を呼び、ヒットを得る"
      - "viewerHub は visibilityController.isVisible(uuid) を用いて不可視 uuid を除外し、可視ヒットのみ {uuid, kind, ...} として返す（無ければ null）"
      - "selector が hub.core.selection.select(uuid, kind?) を呼ぶ（戻り値 null は「不可視/不正で選択不可」も含む）。通常は pickObjectAt 側で不可視は除外済み。"
      - "selectionController が uiState.selection を更新"
      - "UI が micro に入りたい場合は hub.core.mode.focus(uuid) または hub.core.micro.enter(uuid) を呼ぶ"
      - "modeController は内部で canEnter（isFramePlaying / isCameraAuto / visibilityController.isVisible(uuid)）を満たす場合のみ micro に遷移し、microController.refresh() で uiState.microState を更新する"
      - "次フレームの hub tick で renderer.applyMicroFX(uiState.microState) が呼ばれる"
      - "micro に入りたいだけなら hub.core.mode.focus(uuid) だけでもよい（focus 側で select を内包してよい運用とする）。"

    render_loop:
      - "viewerHub.start() は (disposed===false && isRunning===false) のときだけ RAF を開始する（多重 start は no-op）。"
      - "RAF は (isRunning===true && disposed===false) の間だけ継続し、stop/dispose で次フレーム以降を止める。"
      - "各フレーム tick（hub 内部の順序規範）:"
      - "  0) if disposed: return（core/renderer に触らない）"
      - "  1) dtSeconds を算出（推奨: clamp。例: 0〜0.1）"
      - "  2) DI: core.frameController.updatePlayback(dtSeconds)（isFramePlaying のときのみ。frame は setActive 経由で進行させる）"
      - "  3) DI: core.cameraEngine.update(dtSeconds)（AutoOrbit/補間など）"
      - "  4) DI: core.microController.refresh()  # refresh() が mode!=='micro' のとき uiState.microState=null を保証する"
      - "  5) renderer.updateCamera(core.cameraEngine.getState())"
      - "  6) renderer.applyFrame(uiState.visibleSet)"
      - "  7) renderer.applyViewerSettings(uiState.viewerSettings)"
      - "  8) renderer.applyMicroFX(uiState.microState)"
      - "  9) if (uiState.mode === 'macro' && uiState.microState === null) renderer.applySelection(uiState.selection)"
      - " 10) renderer.render()"

      - "優先順位（規範）: microFX > selection（macro） > baseStyle（= 競合させない。micro 中は selection を適用しない）"

    resize_update:
      - "Host が canvas（または wrapper）のサイズ変化を検知する（ResizeObserver 推奨）"
      - "Host が width=canvas.clientWidth, height=canvas.clientHeight を計算する"
      - "Host が hub.resize(width, height) を呼ぶ（UI→renderer 直結は禁止のため hub 経由が正規ルート）"
      - "hub.resize が renderer.resize(width,height) を呼び、renderer が setSize + camera.aspect 更新を行う"
      - "hub.resize は続けて renderer.updateCamera(hub.core.camera.getState()) を呼ぶ（resize 後の確定反映）"
