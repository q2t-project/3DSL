runtime_spec:
  version: "2.0"
  description: "3DSL Viewer Runtime Manifest – holy API spec for 3DSL Viewer"

  # =========================================================
  # 0. レイヤ定義 ＋ 依存ルール
  # =========================================================
  layers:
    - name: entry
      description: "Host（Astro/HTML）から叩かれるエントリポイント層"
    - name: hub
      description: "UI と core / renderer の集線層（ロジック禁止）"
    - name: core
      description: "状態とビジネスロジックの中枢。3DSS は read-only"
    - name: renderer
      description: "three.js による描画専用。state-less 指向"
    - name: ui
      description: "UI イベント → hub.core.* への橋渡し層"

  dependency_rules:
    # 正方向
    - "ui        → hub       → core      → renderer"

    # 禁止方向（絶対）
    - "core      → hub:       FORBIDDEN"
    - "renderer  → core:      FORBIDDEN"
    - "renderer  → hub:       FORBIDDEN"
    - "hub       → ui:        FORBIDDEN"
    - "ui        → renderer:  FORBIDDEN（pick も hub 経由）"

  # =========================================================
  # 1. state 所有権
  # =========================================================
  ownership:
    uiState:        "core"
    visibleSet:     "core"
    microState:     "core"
    cameraState:    "core"
    document_3dss:  "core (immutable)"
    three_objects:  "renderer"

  # =========================================================
  # 2. モジュール一覧
  # =========================================================
  modules:

    # =========================
    # 2.1 entry
    # =========================
    - name: runtime/bootstrapViewer.js
      layer: entry
      responsibility:
        - "canvas と 3DSS JSON を受け取り、runtime 一式を初期化する"
        - "URL から JSON をロードし、AJV で strict validate する"
        - "core / renderer / viewerHub を生成して返す"
      exports:
        - name: bootstrapViewer
          signature: "(canvasOrId, threeDSS, options?) → hub"
        - name: bootstrapViewerFromUrl
          signature: "(canvasOrId, url, options?) → Promise<hub>"
      calls:
        - runtime/core/uiState.createUiState
        - runtime/core/structIndex.buildUUIDIndex
        - runtime/core/structIndex.detectFrameRange
        - runtime/core/CameraEngine (constructor)
        - runtime/core/frameController.createFrameController
        - runtime/core/selectionController.createSelectionController
        - runtime/core/microController.createMicroController
        - runtime/core/visibilityController.createVisibilityController
        - runtime/core/modeController.createModeController
        - runtime/renderer/context.createRendererContext
        - runtime/viewerHub.createViewerHub
      called_by:
        - "Host（Astro / HTML 側の起動コード）"
      constraints:
        - "描画ループ（requestAnimationFrame）は持たない。hub.start に任せる"
        - "ui/* モジュールを import してはならない"
        - "3DSS が AJV で NG の場合は hub を生成せず Error を投げる"
        - "3DSS document は immutable とみなす"

    # =========================
    # 2.2 hub
    # =========================
    - name: runtime/viewerHub.js
      layer: hub
      responsibility:
        - "core と renderer を束ねて、UI に対して hub.core.* API を提供する"
        - "render loop（hub.start / hub.stop）を 1 箇所で管理する"
        - "UI からの呼び出しはすべて hub.core.* / hub.pickObjectAt に統一する"
      exports:
        - name: createViewerHub
          signature: "({ core, renderer }) → hub"
        - name: hub
          children:
            - core
            - start
            - stop
            - pickObjectAt
      calls:
        - "core/frameController.*"
        - "core/selectionController.*"
        - "core/modeController.*"
        - "core/microController.*"
        - "core/visibilityController.*"
        - "core/cameraEngine.*"
        - "renderer/context.applyFrame"
        - "renderer/context.applyMicroFX"
        - "renderer/context.updateCamera"
        - "renderer/context.applySelection"
        - "renderer/context.pickObjectAt"
        - "renderer/context.render"
      called_by:
        - "ui/pointerInput.js"
        - "ui/keyboardInput.js"
        - "ui/gizmo.js"
        - "ui/picker.js"
        - "ui/timeline.js"
      constraints:
        - "frame/mode/micro/selection の判定ロジックを hub に書いてはならない。必ず core.* に委譲する"
        - "three.js のオブジェクトや material を直接触ってはならない"
        - "3DSS document を直接変更してはならない"

      core_api:
        frame:
          - name: set
            signature: "(frameIndex:number) → void"
            calls:
              - core/frameController.set
          - name: get
            signature: "() → number"
            calls:
              - core/frameController.get
          - name: step
            signature: "(delta:number) → void"
            calls:
              - core/frameController.step
          - name: range
            signature: "() → {min:number,max:number}"
            calls:
              - core/frameController.range
          - name: startPlayback
            signature: "() → void"
            calls:
              - core/frameController.startPlayback
          - name: stopPlayback
            signature: "() → void"
            calls:
              - core/frameController.stopPlayback

        selection:
          - name: select
            signature: "(uuid:string) → {kind:string|null, uuid:string|null}"
            calls:
              - core/selectionController.select
          - name: clear
            signature: "() → {kind:null, uuid:null}"
            calls:
              - core/selectionController.clear
          - name: get
            signature: "() → {kind:string|null, uuid:string|null}"
            calls:
              - core/selectionController.get

        camera:
          - name: rotate
            signature: "(dTheta:number, dPhi:number) → void"
            calls:
              - core/cameraEngine.rotate
          - name: pan
            signature: "(dx:number, dy:number) → void"
            calls:
              - core/cameraEngine.pan
          - name: zoom
            signature: "(delta:number) → void"
            calls:
              - core/cameraEngine.zoom
          - name: reset
            signature: "() → void"
            calls:
              - core/cameraEngine.reset
          - name: snapToAxis
            signature: "(axis:'x'|'y'|'z') → void"
            calls:
              - core/cameraEngine.snapToAxis
          - name: focusOn
            signature: "(uuid:string) → void"
            calls:
              - core/selectionController.select
          - name: setFOV
            signature: "(value:number) → void"
            calls:
              - core/cameraEngine.setFOV
          - name: setState
            signature: "(partialState:object) → void"
            calls:
              - core/cameraEngine.setState
          - name: getState
            signature: "() → cameraState"
            calls:
              - core/cameraEngine.getState

        mode:
          - name: set
            signature: "(mode:'macro'|'meso'|'micro', uuid?:string) → 'macro'|'meso'|'micro'"
            calls:
              - core/modeController.set
          - name: get
            signature: "() → 'macro'|'meso'|'micro'"
            calls:
              - core/modeController.get
          - name: canEnter
            signature: "(uuid:string) → boolean"
            calls:
              - core/modeController.canEnter
          - name: exit
            signature: "() → void"
            calls:
              - core/modeController.exit
          - name: focus
            signature: "(uuid:string) → void"
            calls:
              - core/modeController.focus

        micro:
          - name: enter
            signature: "(uuid:string) → void"
            calls:
              - core/modeController.set('micro', uuid)
          - name: exit
            signature: "() → void"
            calls:
              - core/modeController.exit
          - name: isActive
            signature: "() → boolean"
            impl_note: "uiState.mode === 'micro' を見るだけ（core 所有）"

        filters:
          - name: setTypeEnabled
            signature: "(kind:'points'|'lines'|'aux', enabled:boolean) → void"
            calls:
              - core/visibilityController.setTypeFilter
          - name: get
            signature: "() → FiltersState"
            calls:
              - core/visibilityController.getFilters

        runtime:
          - name: isFramePlaying
            signature: "() → boolean"
            impl_note: "uiState.runtime.isFramePlaying を返す（core 所有）"
          - name: isCameraAuto
            signature: "() → boolean"
            impl_note: "uiState.runtime.isCameraAuto を返す（core 所有）"

    # =========================
    # 2.3 core
    # =========================
    - name: runtime/core/cameraEngine.js
      layer: core
      responsibility:
        - "cameraState を内部に保持し、renderer に渡すための状態を作る"
      exports:
        - name: CameraEngine
          type: class
          methods:
            - rotate(dTheta:number, dPhi:number)
            - pan(dx:number, dy:number)
            - zoom(delta:number)
            - reset()
            - snapToAxis(axis:'x'|'y'|'z')
            - setState(partialState:object)
            - getState(): cameraState
            - setFOV(value:number)
      calls: []
      called_by:
        - "runtime/viewerHub.js（core.camera.* 経由）"
        - "core/modeController.js（フォーカス遷移時に参照する場合があれば）"
      state:
        - "cameraState を内部に保持する"
        - "three.js の Camera インスタンスは renderer が保持し、この state を反映するだけ"

    - name: runtime/core/frameController.js
      layer: core
      responsibility:
        - "active frame を管理する"
        - "frame 再生ループの進行を管理する（interval / rAF のどちらでも良いが hub から呼ばれる）"
      exports:
        - name: createFrameController
          returns: frameController
        - name: frameController
          methods:
            - set(frameIndex:number)
            - get(): number
            - step(delta:number)
            - range(): {min:number,max:number}
            - startPlayback(onStep:(frameIndex:number)=>void)
            - stopPlayback()
      calls:
        - core/visibilityController.recompute
      called_by:
        - "runtime/viewerHub.js（core.frame.* 経由）"
        - "core/modeController.js（必要であれば）"
      state:
        - "activeFrame と frameRange を uiState.frame に保持する"

    - name: runtime/core/selectionController.js
      layer: core
      responsibility:
        - "現在の選択要素（kind, uuid）を管理する"
      exports:
        - name: createSelectionController
          returns: selectionController
        - name: selectionController
          methods:
            - select(uuid:string)
            - clear()
            - get(): {kind:string|null, uuid:string|null}
      calls:
        - core/structIndex.buildUUIDIndex（が作った index を参照）
      called_by:
        - "runtime/viewerHub.js（core.selection.*）"
        - "core/modeController.js"
      state:
        - "uiState.selection = {kind, uuid} を更新する"

    - name: runtime/core/modeController.js
      layer: core
      responsibility:
        - "mode（macro/meso/micro）と micro 侵入条件の優先ルールを管理する"
      exports:
        - name: createModeController
          returns: modeController
        - name: modeController
          methods:
            - set(mode:'macro'|'meso'|'micro', uuid?:string)
            - get(): 'macro'|'meso'|'micro'
            - canEnter(uuid:string): boolean
            - exit()
            - focus(uuid:string)
      calls:
        - core/selectionController.select
        - core/selectionController.get
        - core/microController.compute
        - core/frameController.get
        - core/visibilityController.isVisible
      called_by:
        - "runtime/viewerHub.js（core.mode.*, core.micro.*）"
      rules:
        - "frame 再生開始時は必ず mode='macro' に戻す（frameController.startPlayback の責務でもよい）"
        - "micro/meso は visibleSet 内の要素にだけ適用される"
        - "canEnter は isFramePlaying / isCameraAuto / visibleSet をチェックする"
      state:
        - "uiState.mode を更新する"
        - "uiState.microState を microController.compute の結果で更新する"

    - name: runtime/core/microController.js
      layer: core
      responsibility:
        - "selection + cameraState + structIndex から microState を算出する"
      exports:
        - name: createMicroController
          returns: microController
        - name: microController
          methods:
            - compute(selection, cameraState, struct): microState
      calls:
        - core/structIndex（uuid→kind / 近傍情報などを参照）
      called_by:
        - "core/modeController"
      constraints:
        - "three.js を import してはならない"
        - "renderer に直接アクセスしてはならない"
      microState_shape:
        - "最低限: { focusUuid, kind, cameraSnapshot, meta? }"
        - "renderer は unknown なフィールドは無視して良い"

    - name: runtime/core/visibilityController.js
      layer: core
      responsibility:
        - "appearance.visible / frames / filters を合成し、visibleSet を計算する"
      exports:
        - name: createVisibilityController
          returns: visibilityController
        - name: visibilityController
          methods:
            - recompute(): visibleSet
            - isVisible(uuid:string): boolean
            - getFilters(): FiltersState
            - setTypeFilter(kind:'points'|'lines'|'aux', enabled:boolean)
      calls: []
      called_by:
        - "runtime/viewerHub.js（core.filters.*）"
        - "core/frameController"
        - "core/modeController"
      state:
        - "uiState.visibleSet を Set<uuid> として保持する"

    - name: runtime/core/uiState.js
      layer: core
      responsibility:
        - "viewer の UI 状態を一元管理する（document とは分離）"
      exports:
        - name: createUiState
          returns: uiState
      fields:
        - "frame.current: number"
        - "frame.range: {min:number,max:number}"
        - "selection: {kind:string|null, uuid:string|null}"
        - "cameraState: {theta,phi,distance,target(x,y,z),fov}"
        - "mode: 'macro'|'meso'|'micro'"
        - "filters: {points:boolean,lines:boolean,aux:boolean}"
        - "runtime.isFramePlaying: boolean"
        - "runtime.isCameraAuto: boolean"
        - "microState: any"
        - "viewerSettings: object"

    - name: runtime/core/structIndex.js
      layer: core
      responsibility:
        - "3DSS document から uuid インデックスと frameRange を構築する"
      exports:
        - name: buildUUIDIndex
          signature: "(document) → Map<uuid,kind>"
        - name: detectFrameRange
          signature: "(document) → {min:number,max:number}"
      called_by:
        - "bootstrapViewer"
        - "visibilityController"
        - "selectionController"
        - "microController"

    # =========================
    # 2.4 renderer
    # =========================
    - name: runtime/renderer/context.js
      layer: renderer
      responsibility:
        - "three.js renderer / scene / camera を初期化し、Core から渡された状態を描画する"
      exports:
        - name: createRendererContext
          returns: rendererContext
        - name: rendererContext
          methods:
            - syncDocument(document, indices)
            - applyFrame(visibleSet)
            - updateCamera(cameraState)
            - applyMicroFX(microState)
            - applySelection(selectionState)
            - pickObjectAt(ndcX:number, ndcY:number): {uuid, distance, point} | null
            - render()
      internal_state:
        - "renderer: THREE.WebGLRenderer"
        - "scene: THREE.Scene"
        - "camera: THREE.PerspectiveCamera"
        - "lights: AmbientLight + DirectionalLight"
        - "pointObjects: Map<uuid,THREE.Object3D>"
        - "lineObjects: Map<uuid,THREE.Object3D>"
        - "auxObjects: Map<uuid,THREE.Object3D>"
        - "baseStyle: Map<uuid,{color:THREE.Color,opacity:number}>"
        - "raycaster: THREE.Raycaster"
      lifecycle:
        init:
          - "new THREE.WebGLRenderer({ canvas, antialias:true })"
          - "renderer.setPixelRatio(window.devicePixelRatio || 1)"
          - "renderer.setSize(canvas.clientWidth, canvas.clientHeight, false)"
          - "scene = new THREE.Scene()"
          - "camera = new THREE.PerspectiveCamera(fov, aspect, near, far)"
          - "scene に AmbientLight / DirectionalLight を追加"
        syncDocument:
          - "前回の point/line/aux オブジェクトを scene から remove & Map を clear"
          - "3DSS document の points/lines/aux から三次元オブジェクトを生成"
          - "各オブジェクトに userData.uuid を付与し、対応する Map に登録"
          - "baseStyle Map に元の color / opacity を保存"
        applyFrame:
          - "visibleSet: Set<uuid> を受け取り、各オブジェクトの obj.visible を更新"
        applyMicroFX:
          - "microState が null の場合: baseStyle に従って color/opacity をフルリセット"
          - "microState があれば: focus / connection / distance などに応じて opacity / color を変更（詳細ロジックは任意だが 3DSS/struct は書き換えない）"
        updateCamera:
          - "camera.position / camera.up を cameraState から設定"
          - "target ベクトルに対して camera.lookAt(target)"
          - "fov が変わった場合は camera.fov 更新 ＋ updateProjectionMatrix()"
        applySelection:
          - "selectionState（{kind,uuid}）を受け取り、選択中要素の軽いハイライトを適用してもよい（必須ではない）"
        pickObjectAt:
          - "raycaster.setFromCamera({x:ndcX,y:ndcY}, camera)"
          - "raycaster.intersectObjects(scene.children, true) から userData.uuid を持つ最前面ヒットを返す"
        render:
          - "renderer.render(scene, camera)"
      calls: []
      called_by:
        - "bootstrapViewer（初期化）"
        - "runtime/viewerHub.js"
      constraints:
        - "3DSS document を書き換えてはならない"
        - "visibleSet / microState / selectionState / cameraState の canonical 所有者は core であり、renderer は各フレームで受け取って反映するだけ"
        - "mode や selection の判定ロジックを実装してはならない"
        - "UI layer は renderer を直接 import してはならない（pickObjectAt も必ず viewerHub.pickObjectAt 経由）"

    # =========================
    # 2.5 UI Bridge
    # =========================
    - name: ui/pointerInput.js
      layer: ui
      responsibility:
        - "マウス操作（ドラッグ・ホイール）を camera/mode 操作にマッピングする"
      exports:
        - name: createPointerInput
          returns: pointerInput
        - name: pointerInput
          methods:
            - attach(domElement)
            - detach()
      calls:
        - runtime/viewerHub.core.camera.rotate
        - runtime/viewerHub.core.camera.pan
        - runtime/viewerHub.core.camera.zoom
        - runtime/viewerHub.core.mode.set
      called_by:
        - "Host UI 初期化コード"

    - name: ui/keyboardInput.js
      layer: ui
      responsibility:
        - "キーボードショートカットを camera/frame/mode 操作にマッピングする"
      exports:
        - name: createKeyboardInput
          returns: keyboardInput
      calls:
        - runtime/viewerHub.core.camera.*
        - runtime/viewerHub.core.frame.*
        - runtime/viewerHub.core.mode.*
      called_by:
        - "Host UI 初期化コード"

    - name: ui/gizmo.js
      layer: ui
      responsibility:
        - "画面左下の HUD 軸ギズモを描画し、クリックで camera snap/home を呼ぶ"
      exports:
        - name: initGizmo
        - name: updateGizmoOrientation
      calls:
        - runtime/viewerHub.core.camera.snapToAxis
        - runtime/viewerHub.core.camera.reset
      constraints:
        - "three.js 本体の scene には入らず、HUD overlay として DOM で描画する"

    - name: ui/picker.js
      layer: ui
      responsibility:
        - "canvas 上のクリック座標から uuid を取得し、selection を更新する"
      exports:
        - name: createPicker
          returns: picker
        - name: picker
          methods:
            - attach(domElement)
            - detach()
      calls:
        - runtime/viewerHub.pickObjectAt
        - runtime/viewerHub.core.selection.select
      called_by:
        - "Host UI 初期化コード"

    - name: ui/timeline.js
      layer: ui
      responsibility:
        - "frame scrub / play/pause UI と core.frame.* を接続する"
      exports:
        - name: createTimeline
          returns: timeline
      calls:
        - runtime/viewerHub.core.frame.set
        - runtime/viewerHub.core.frame.step
        - runtime/viewerHub.core.frame.startPlayback
        - runtime/viewerHub.core.frame.stopPlayback
      called_by:
        - "Host UI 初期化コード"

  # =========================================================
  # 3. Runtime フロー
  # =========================================================
  runtime_flow:
    startup:
      - "Host が bootstrapViewerFromUrl(canvas, url, options) or bootstrapViewer(canvas, doc, options) を呼ぶ"
      - "bootstrapViewer が JSON load → AJV validate → uiState / indices / rendererContext / viewerHub を生成"
      - "Host が ui/* を初期化し、hub.core.* / hub.pickObjectAt にイベントを接続する"

    frame_update:
      - "UI が hub.core.frame.set/step を呼ぶ"
      - "core.frameController が activeFrame を更新し、visibilityController.recompute() で uiState.visibleSet を更新"
      - "次フレームの hub tick で renderer.applyFrame(uiState.visibleSet) が呼ばれる"

    selection_update:
      - "UI picker が canvas 座標から NDC 座標を計算し、hub.pickObjectAt(ndcX, ndcY) を呼ぶ"
      - "viewerHub が renderer.pickObjectAt を呼び、{uuid,...} を返す"
      - "picker が hub.core.selection.select(uuid) を呼ぶ"
      - "selectionController が uiState.selection を更新"
      - "modeController が必要なら micro へ遷移し、microController.compute() → uiState.microState を更新"
      - "次フレームの hub tick で renderer.applyMicroFX(uiState.microState) が呼ばれる"

    render_loop:
      - "viewerHub.start() が内部で requestAnimationFrame ループを開始"
      - "各フレーム tick で:"
      - "  1) renderer.updateCamera(uiState.cameraState)"
      - "  2) renderer.applyFrame(uiState.visibleSet)"
      - "  3) renderer.applyMicroFX(uiState.microState)"
      - "  4) renderer.applySelection(uiState.selection)（必要なら）"
      - "  5) renderer.render()"
